# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from . import outputs
from ... import meta as _meta

__all__ = [
    'VaultAuth',
    'VaultAuthSpec',
    'VaultAuthSpecAppRole',
    'VaultAuthSpecAppRolePatch',
    'VaultAuthSpecAws',
    'VaultAuthSpecAwsPatch',
    'VaultAuthSpecJwt',
    'VaultAuthSpecJwtPatch',
    'VaultAuthSpecKubernetes',
    'VaultAuthSpecKubernetesPatch',
    'VaultAuthSpecPatch',
    'VaultAuthSpecStorageEncryption',
    'VaultAuthSpecStorageEncryptionPatch',
    'VaultAuthStatus',
    'VaultAuthStatusPatch',
    'VaultConnection',
    'VaultConnectionSpec',
    'VaultConnectionSpecPatch',
    'VaultConnectionStatus',
    'VaultConnectionStatusPatch',
    'VaultDynamicSecret',
    'VaultDynamicSecretSpec',
    'VaultDynamicSecretSpecDestination',
    'VaultDynamicSecretSpecDestinationPatch',
    'VaultDynamicSecretSpecPatch',
    'VaultDynamicSecretSpecRolloutRestartTargets',
    'VaultDynamicSecretSpecRolloutRestartTargetsPatch',
    'VaultDynamicSecretStatus',
    'VaultDynamicSecretStatusPatch',
    'VaultDynamicSecretStatusSecretLease',
    'VaultDynamicSecretStatusSecretLeasePatch',
    'VaultDynamicSecretStatusStaticCredsMetaData',
    'VaultDynamicSecretStatusStaticCredsMetaDataPatch',
    'VaultPKISecret',
    'VaultPKISecretSpec',
    'VaultPKISecretSpecDestination',
    'VaultPKISecretSpecDestinationPatch',
    'VaultPKISecretSpecPatch',
    'VaultPKISecretSpecRolloutRestartTargets',
    'VaultPKISecretSpecRolloutRestartTargetsPatch',
    'VaultPKISecretStatus',
    'VaultPKISecretStatusPatch',
    'VaultStaticSecret',
    'VaultStaticSecretSpec',
    'VaultStaticSecretSpecDestination',
    'VaultStaticSecretSpecDestinationPatch',
    'VaultStaticSecretSpecPatch',
    'VaultStaticSecretSpecRolloutRestartTargets',
    'VaultStaticSecretSpecRolloutRestartTargetsPatch',
    'VaultStaticSecretStatus',
    'VaultStaticSecretStatusPatch',
]

@pulumi.output_type
class VaultAuth(dict):
    """
    VaultAuth is the Schema for the vaultauths API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuth. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuth.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuth.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.VaultAuthSpec'] = None,
                 status: Optional['outputs.VaultAuthStatus'] = None):
        """
        VaultAuth is the Schema for the vaultauths API
        :param _builtins.str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param _builtins.str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultAuth')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.VaultAuthSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.VaultAuthStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class VaultAuthSpec(dict):
    """
    VaultAuthSpec defines the desired state of VaultAuth
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedNamespaces":
            suggest = "allowed_namespaces"
        elif key == "appRole":
            suggest = "app_role"
        elif key == "storageEncryption":
            suggest = "storage_encryption"
        elif key == "vaultConnectionRef":
            suggest = "vault_connection_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_namespaces: Optional[Sequence[_builtins.str]] = None,
                 app_role: Optional['outputs.VaultAuthSpecAppRole'] = None,
                 aws: Optional['outputs.VaultAuthSpecAws'] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 jwt: Optional['outputs.VaultAuthSpecJwt'] = None,
                 kubernetes: Optional['outputs.VaultAuthSpecKubernetes'] = None,
                 method: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None,
                 storage_encryption: Optional['outputs.VaultAuthSpecStorageEncryption'] = None,
                 vault_connection_ref: Optional[_builtins.str] = None):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        :param Sequence[_builtins.str] allowed_namespaces: AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        :param Mapping[str, _builtins.str] headers: Headers to be included in all Vault requests.
        :param _builtins.str method: Method to use when authenticating to Vault.
        :param _builtins.str mount: Mount to use when authenticating to auth method.
        :param _builtins.str namespace: Namespace to auth to in Vault
        :param Mapping[str, _builtins.str] params: Params to use when authenticating to Vault
        :param _builtins.str vault_connection_ref: VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        if allowed_namespaces is not None:
            pulumi.set(__self__, "allowed_namespaces", allowed_namespaces)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if storage_encryption is not None:
            pulumi.set(__self__, "storage_encryption", storage_encryption)
        if vault_connection_ref is not None:
            pulumi.set(__self__, "vault_connection_ref", vault_connection_ref)

    @_builtins.property
    @pulumi.getter(name="allowedNamespaces")
    def allowed_namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        return pulumi.get(self, "allowed_namespaces")

    @_builtins.property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional['outputs.VaultAuthSpecAppRole']:
        return pulumi.get(self, "app_role")

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional['outputs.VaultAuthSpecAws']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional['outputs.VaultAuthSpecJwt']:
        return pulumi.get(self, "jwt")

    @_builtins.property
    @pulumi.getter
    def kubernetes(self) -> Optional['outputs.VaultAuthSpecKubernetes']:
        return pulumi.get(self, "kubernetes")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Method to use when authenticating to Vault.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount to use when authenticating to auth method.
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to auth to in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Params to use when authenticating to Vault
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter(name="storageEncryption")
    def storage_encryption(self) -> Optional['outputs.VaultAuthSpecStorageEncryption']:
        return pulumi.get(self, "storage_encryption")

    @_builtins.property
    @pulumi.getter(name="vaultConnectionRef")
    def vault_connection_ref(self) -> Optional[_builtins.str]:
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_connection_ref")


@pulumi.output_type
class VaultAuthSpecAppRole(dict):
    """
    AppRole specific auth configuration, requires that the Method be set to `appRole`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecAppRole. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecAppRole.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecAppRole.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        :param _builtins.str role_id: RoleID of the AppRole Role to use for authenticating to Vault.
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class VaultAuthSpecAppRolePatch(dict):
    """
    AppRole specific auth configuration, requires that the Method be set to `appRole`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "roleId":
            suggest = "role_id"
        elif key == "secretRef":
            suggest = "secret_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecAppRolePatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecAppRolePatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecAppRolePatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role_id: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        :param _builtins.str role_id: RoleID of the AppRole Role to use for authenticating to Vault.
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[_builtins.str]:
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role_id")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        return pulumi.get(self, "secret_ref")


@pulumi.output_type
class VaultAuthSpecAws(dict):
    """
    AWS specific auth configuration, requires that Method be set to `aws`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerValue":
            suggest = "header_value"
        elif key == "iamEndpoint":
            suggest = "iam_endpoint"
        elif key == "irsaServiceAccount":
            suggest = "irsa_service_account"
        elif key == "secretRef":
            suggest = "secret_ref"
        elif key == "sessionName":
            suggest = "session_name"
        elif key == "stsEndpoint":
            suggest = "sts_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecAws. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecAws.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecAws.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_value: Optional[_builtins.str] = None,
                 iam_endpoint: Optional[_builtins.str] = None,
                 irsa_service_account: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 session_name: Optional[_builtins.str] = None,
                 sts_endpoint: Optional[_builtins.str] = None):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        :param _builtins.str header_value: The Vault header value to include in the STS signing request
        :param _builtins.str iam_endpoint: The IAM endpoint to use; if not set will use the default
        :param _builtins.str irsa_service_account: IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        :param _builtins.str region: AWS Region to use for signing the authentication request
        :param _builtins.str role: Vault role to use for authenticating
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        :param _builtins.str session_name: The role session name to use when creating a webidentity provider
        :param _builtins.str sts_endpoint: The STS endpoint to use; if not set will use the default
        """
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if iam_endpoint is not None:
            pulumi.set(__self__, "iam_endpoint", iam_endpoint)
        if irsa_service_account is not None:
            pulumi.set(__self__, "irsa_service_account", irsa_service_account)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if session_name is not None:
            pulumi.set(__self__, "session_name", session_name)
        if sts_endpoint is not None:
            pulumi.set(__self__, "sts_endpoint", sts_endpoint)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The Vault header value to include in the STS signing request
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter(name="iamEndpoint")
    def iam_endpoint(self) -> Optional[_builtins.str]:
        """
        The IAM endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "iam_endpoint")

    @_builtins.property
    @pulumi.getter(name="irsaServiceAccount")
    def irsa_service_account(self) -> Optional[_builtins.str]:
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        return pulumi.get(self, "irsa_service_account")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        AWS Region to use for signing the authentication request
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Vault role to use for authenticating
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="sessionName")
    def session_name(self) -> Optional[_builtins.str]:
        """
        The role session name to use when creating a webidentity provider
        """
        return pulumi.get(self, "session_name")

    @_builtins.property
    @pulumi.getter(name="stsEndpoint")
    def sts_endpoint(self) -> Optional[_builtins.str]:
        """
        The STS endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "sts_endpoint")


@pulumi.output_type
class VaultAuthSpecAwsPatch(dict):
    """
    AWS specific auth configuration, requires that Method be set to `aws`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "headerValue":
            suggest = "header_value"
        elif key == "iamEndpoint":
            suggest = "iam_endpoint"
        elif key == "irsaServiceAccount":
            suggest = "irsa_service_account"
        elif key == "secretRef":
            suggest = "secret_ref"
        elif key == "sessionName":
            suggest = "session_name"
        elif key == "stsEndpoint":
            suggest = "sts_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecAwsPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecAwsPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecAwsPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 header_value: Optional[_builtins.str] = None,
                 iam_endpoint: Optional[_builtins.str] = None,
                 irsa_service_account: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 role: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 session_name: Optional[_builtins.str] = None,
                 sts_endpoint: Optional[_builtins.str] = None):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        :param _builtins.str header_value: The Vault header value to include in the STS signing request
        :param _builtins.str iam_endpoint: The IAM endpoint to use; if not set will use the default
        :param _builtins.str irsa_service_account: IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        :param _builtins.str region: AWS Region to use for signing the authentication request
        :param _builtins.str role: Vault role to use for authenticating
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        :param _builtins.str session_name: The role session name to use when creating a webidentity provider
        :param _builtins.str sts_endpoint: The STS endpoint to use; if not set will use the default
        """
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if iam_endpoint is not None:
            pulumi.set(__self__, "iam_endpoint", iam_endpoint)
        if irsa_service_account is not None:
            pulumi.set(__self__, "irsa_service_account", irsa_service_account)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if session_name is not None:
            pulumi.set(__self__, "session_name", session_name)
        if sts_endpoint is not None:
            pulumi.set(__self__, "sts_endpoint", sts_endpoint)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[_builtins.str]:
        """
        The Vault header value to include in the STS signing request
        """
        return pulumi.get(self, "header_value")

    @_builtins.property
    @pulumi.getter(name="iamEndpoint")
    def iam_endpoint(self) -> Optional[_builtins.str]:
        """
        The IAM endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "iam_endpoint")

    @_builtins.property
    @pulumi.getter(name="irsaServiceAccount")
    def irsa_service_account(self) -> Optional[_builtins.str]:
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        return pulumi.get(self, "irsa_service_account")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        AWS Region to use for signing the authentication request
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Vault role to use for authenticating
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="sessionName")
    def session_name(self) -> Optional[_builtins.str]:
        """
        The role session name to use when creating a webidentity provider
        """
        return pulumi.get(self, "session_name")

    @_builtins.property
    @pulumi.getter(name="stsEndpoint")
    def sts_endpoint(self) -> Optional[_builtins.str]:
        """
        The STS endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "sts_endpoint")


@pulumi.output_type
class VaultAuthSpecJwt(dict):
    """
    JWT specific auth configuration, requires that the Method be set to `jwt`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "tokenExpirationSeconds":
            suggest = "token_expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecJwt. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecJwt.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecJwt.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 role: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 service_account: Optional[_builtins.str] = None,
                 token_expiration_seconds: Optional[_builtins.int] = None):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        :param Sequence[_builtins.str] audiences: TokenAudiences to include in the ServiceAccount token.
        :param _builtins.str role: Role to use for authenticating to Vault.
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        :param _builtins.str service_account: ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        :param _builtins.int token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[_builtins.int]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")


@pulumi.output_type
class VaultAuthSpecJwtPatch(dict):
    """
    JWT specific auth configuration, requires that the Method be set to `jwt`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretRef":
            suggest = "secret_ref"
        elif key == "serviceAccount":
            suggest = "service_account"
        elif key == "tokenExpirationSeconds":
            suggest = "token_expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecJwtPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecJwtPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecJwtPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 role: Optional[_builtins.str] = None,
                 secret_ref: Optional[_builtins.str] = None,
                 service_account: Optional[_builtins.str] = None,
                 token_expiration_seconds: Optional[_builtins.int] = None):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        :param Sequence[_builtins.str] audiences: TokenAudiences to include in the ServiceAccount token.
        :param _builtins.str role: Role to use for authenticating to Vault.
        :param _builtins.str secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        :param _builtins.str service_account: ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        :param _builtins.int token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[_builtins.str]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        return pulumi.get(self, "secret_ref")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[_builtins.int]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")


@pulumi.output_type
class VaultAuthSpecKubernetes(dict):
    """
    Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"
        elif key == "tokenExpirationSeconds":
            suggest = "token_expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecKubernetes. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecKubernetes.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecKubernetes.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 role: Optional[_builtins.str] = None,
                 service_account: Optional[_builtins.str] = None,
                 token_expiration_seconds: Optional[_builtins.int] = None):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        :param Sequence[_builtins.str] audiences: TokenAudiences to include in the ServiceAccount token.
        :param _builtins.str role: Role to use for authenticating to Vault.
        :param _builtins.str service_account: ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        :param _builtins.int token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[_builtins.int]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")


@pulumi.output_type
class VaultAuthSpecKubernetesPatch(dict):
    """
    Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"
        elif key == "tokenExpirationSeconds":
            suggest = "token_expiration_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecKubernetesPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecKubernetesPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecKubernetesPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audiences: Optional[Sequence[_builtins.str]] = None,
                 role: Optional[_builtins.str] = None,
                 service_account: Optional[_builtins.str] = None,
                 token_expiration_seconds: Optional[_builtins.int] = None):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        :param Sequence[_builtins.str] audiences: TokenAudiences to include in the ServiceAccount token.
        :param _builtins.str role: Role to use for authenticating to Vault.
        :param _builtins.str service_account: ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        :param _builtins.int token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[Sequence[_builtins.str]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        return pulumi.get(self, "service_account")

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[_builtins.int]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")


@pulumi.output_type
class VaultAuthSpecPatch(dict):
    """
    VaultAuthSpec defines the desired state of VaultAuth
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedNamespaces":
            suggest = "allowed_namespaces"
        elif key == "appRole":
            suggest = "app_role"
        elif key == "storageEncryption":
            suggest = "storage_encryption"
        elif key == "vaultConnectionRef":
            suggest = "vault_connection_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_namespaces: Optional[Sequence[_builtins.str]] = None,
                 app_role: Optional['outputs.VaultAuthSpecAppRolePatch'] = None,
                 aws: Optional['outputs.VaultAuthSpecAwsPatch'] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 jwt: Optional['outputs.VaultAuthSpecJwtPatch'] = None,
                 kubernetes: Optional['outputs.VaultAuthSpecKubernetesPatch'] = None,
                 method: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None,
                 storage_encryption: Optional['outputs.VaultAuthSpecStorageEncryptionPatch'] = None,
                 vault_connection_ref: Optional[_builtins.str] = None):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        :param Sequence[_builtins.str] allowed_namespaces: AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        :param Mapping[str, _builtins.str] headers: Headers to be included in all Vault requests.
        :param _builtins.str method: Method to use when authenticating to Vault.
        :param _builtins.str mount: Mount to use when authenticating to auth method.
        :param _builtins.str namespace: Namespace to auth to in Vault
        :param Mapping[str, _builtins.str] params: Params to use when authenticating to Vault
        :param _builtins.str vault_connection_ref: VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        if allowed_namespaces is not None:
            pulumi.set(__self__, "allowed_namespaces", allowed_namespaces)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if storage_encryption is not None:
            pulumi.set(__self__, "storage_encryption", storage_encryption)
        if vault_connection_ref is not None:
            pulumi.set(__self__, "vault_connection_ref", vault_connection_ref)

    @_builtins.property
    @pulumi.getter(name="allowedNamespaces")
    def allowed_namespaces(self) -> Optional[Sequence[_builtins.str]]:
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        return pulumi.get(self, "allowed_namespaces")

    @_builtins.property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional['outputs.VaultAuthSpecAppRolePatch']:
        return pulumi.get(self, "app_role")

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional['outputs.VaultAuthSpecAwsPatch']:
        return pulumi.get(self, "aws")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional['outputs.VaultAuthSpecJwtPatch']:
        return pulumi.get(self, "jwt")

    @_builtins.property
    @pulumi.getter
    def kubernetes(self) -> Optional['outputs.VaultAuthSpecKubernetesPatch']:
        return pulumi.get(self, "kubernetes")

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[_builtins.str]:
        """
        Method to use when authenticating to Vault.
        """
        return pulumi.get(self, "method")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount to use when authenticating to auth method.
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to auth to in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Params to use when authenticating to Vault
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter(name="storageEncryption")
    def storage_encryption(self) -> Optional['outputs.VaultAuthSpecStorageEncryptionPatch']:
        return pulumi.get(self, "storage_encryption")

    @_builtins.property
    @pulumi.getter(name="vaultConnectionRef")
    def vault_connection_ref(self) -> Optional[_builtins.str]:
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_connection_ref")


@pulumi.output_type
class VaultAuthSpecStorageEncryption(dict):
    """
    StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecStorageEncryption. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecStorageEncryption.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecStorageEncryption.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        :param _builtins.str key_name: KeyName to use for encrypt/decrypt operations via Vault Transit.
        :param _builtins.str mount: Mount path of the Transit engine in Vault.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount path of the Transit engine in Vault.
        """
        return pulumi.get(self, "mount")


@pulumi.output_type
class VaultAuthSpecStorageEncryptionPatch(dict):
    """
    StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "keyName":
            suggest = "key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultAuthSpecStorageEncryptionPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultAuthSpecStorageEncryptionPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultAuthSpecStorageEncryptionPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 key_name: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        :param _builtins.str key_name: KeyName to use for encrypt/decrypt operations via Vault Transit.
        :param _builtins.str mount: Mount path of the Transit engine in Vault.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount path of the Transit engine in Vault.
        """
        return pulumi.get(self, "mount")


@pulumi.output_type
class VaultAuthStatus(dict):
    """
    VaultAuthStatus defines the observed state of VaultAuth
    """
    def __init__(__self__, *,
                 error: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultAuthStatus defines the observed state of VaultAuth
        :param _builtins.bool valid: Valid auth mechanism.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultAuthStatusPatch(dict):
    """
    VaultAuthStatus defines the observed state of VaultAuth
    """
    def __init__(__self__, *,
                 error: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultAuthStatus defines the observed state of VaultAuth
        :param _builtins.bool valid: Valid auth mechanism.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultConnection(dict):
    """
    VaultConnection is the Schema for the vaultconnections API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.VaultConnectionSpec'] = None,
                 status: Optional['outputs.VaultConnectionStatus'] = None):
        """
        VaultConnection is the Schema for the vaultconnections API
        :param _builtins.str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param _builtins.str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultConnection')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.VaultConnectionSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.VaultConnectionStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class VaultConnectionSpec(dict):
    """
    VaultConnectionSpec defines the desired state of VaultConnection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertSecretRef":
            suggest = "ca_cert_secret_ref"
        elif key == "skipTLSVerify":
            suggest = "skip_tls_verify"
        elif key == "tlsServerName":
            suggest = "tls_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultConnectionSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultConnectionSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultConnectionSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 ca_cert_secret_ref: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 skip_tls_verify: Optional[_builtins.bool] = None,
                 tls_server_name: Optional[_builtins.str] = None):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        :param _builtins.str address: Address of the Vault server
        :param _builtins.str ca_cert_secret_ref: CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        :param Mapping[str, _builtins.str] headers: Headers to be included in all Vault requests.
        :param _builtins.bool skip_tls_verify: SkipTLSVerify for TLS connections.
        :param _builtins.str tls_server_name: TLSServerName to use as the SNI host for TLS connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_secret_ref is not None:
            pulumi.set(__self__, "ca_cert_secret_ref", ca_cert_secret_ref)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if skip_tls_verify is not None:
            pulumi.set(__self__, "skip_tls_verify", skip_tls_verify)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Address of the Vault server
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="caCertSecretRef")
    def ca_cert_secret_ref(self) -> Optional[_builtins.str]:
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        return pulumi.get(self, "ca_cert_secret_ref")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="skipTLSVerify")
    def skip_tls_verify(self) -> Optional[_builtins.bool]:
        """
        SkipTLSVerify for TLS connections.
        """
        return pulumi.get(self, "skip_tls_verify")

    @_builtins.property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[_builtins.str]:
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
        return pulumi.get(self, "tls_server_name")


@pulumi.output_type
class VaultConnectionSpecPatch(dict):
    """
    VaultConnectionSpec defines the desired state of VaultConnection
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertSecretRef":
            suggest = "ca_cert_secret_ref"
        elif key == "skipTLSVerify":
            suggest = "skip_tls_verify"
        elif key == "tlsServerName":
            suggest = "tls_server_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultConnectionSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultConnectionSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultConnectionSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[_builtins.str] = None,
                 ca_cert_secret_ref: Optional[_builtins.str] = None,
                 headers: Optional[Mapping[str, _builtins.str]] = None,
                 skip_tls_verify: Optional[_builtins.bool] = None,
                 tls_server_name: Optional[_builtins.str] = None):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        :param _builtins.str address: Address of the Vault server
        :param _builtins.str ca_cert_secret_ref: CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        :param Mapping[str, _builtins.str] headers: Headers to be included in all Vault requests.
        :param _builtins.bool skip_tls_verify: SkipTLSVerify for TLS connections.
        :param _builtins.str tls_server_name: TLSServerName to use as the SNI host for TLS connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_secret_ref is not None:
            pulumi.set(__self__, "ca_cert_secret_ref", ca_cert_secret_ref)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if skip_tls_verify is not None:
            pulumi.set(__self__, "skip_tls_verify", skip_tls_verify)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[_builtins.str]:
        """
        Address of the Vault server
        """
        return pulumi.get(self, "address")

    @_builtins.property
    @pulumi.getter(name="caCertSecretRef")
    def ca_cert_secret_ref(self) -> Optional[_builtins.str]:
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        return pulumi.get(self, "ca_cert_secret_ref")

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @_builtins.property
    @pulumi.getter(name="skipTLSVerify")
    def skip_tls_verify(self) -> Optional[_builtins.bool]:
        """
        SkipTLSVerify for TLS connections.
        """
        return pulumi.get(self, "skip_tls_verify")

    @_builtins.property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[_builtins.str]:
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
        return pulumi.get(self, "tls_server_name")


@pulumi.output_type
class VaultConnectionStatus(dict):
    """
    VaultConnectionStatus defines the observed state of VaultConnection
    """
    def __init__(__self__, *,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultConnectionStatus defines the observed state of VaultConnection
        :param _builtins.bool valid: Valid auth mechanism.
        """
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultConnectionStatusPatch(dict):
    """
    VaultConnectionStatus defines the observed state of VaultConnection
    """
    def __init__(__self__, *,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultConnectionStatus defines the observed state of VaultConnection
        :param _builtins.bool valid: Valid auth mechanism.
        """
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultDynamicSecret(dict):
    """
    VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.VaultDynamicSecretSpec'] = None,
                 status: Optional['outputs.VaultDynamicSecretStatus'] = None):
        """
        VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
        :param _builtins.str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param _builtins.str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultDynamicSecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.VaultDynamicSecretSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.VaultDynamicSecretStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class VaultDynamicSecretSpec(dict):
    """
    VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowStaticCreds":
            suggest = "allow_static_creds"
        elif key == "renewalPercent":
            suggest = "renewal_percent"
        elif key == "requestHTTPMethod":
            suggest = "request_http_method"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_static_creds: Optional[_builtins.bool] = None,
                 destination: Optional['outputs.VaultDynamicSecretSpecDestination'] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None,
                 path: Optional[_builtins.str] = None,
                 renewal_percent: Optional[_builtins.int] = None,
                 request_http_method: Optional[_builtins.str] = None,
                 revoke: Optional[_builtins.bool] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultDynamicSecretSpecRolloutRestartTargets']] = None,
                 vault_auth_ref: Optional[_builtins.str] = None):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        :param _builtins.bool allow_static_creds: AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        :param _builtins.str mount: Mount path of the secret's engine in Vault.
        :param _builtins.str namespace: Namespace where the secrets engine is mounted in Vault.
        :param Mapping[str, _builtins.str] params: Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        :param _builtins.str path: Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        :param _builtins.int renewal_percent: RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        :param _builtins.str request_http_method: RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        :param _builtins.bool revoke: Revoke the existing lease on VDS resource deletion.
        :param Sequence['VaultDynamicSecretSpecRolloutRestartTargetsArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if allow_static_creds is not None:
            pulumi.set(__self__, "allow_static_creds", allow_static_creds)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if renewal_percent is not None:
            pulumi.set(__self__, "renewal_percent", renewal_percent)
        if request_http_method is not None:
            pulumi.set(__self__, "request_http_method", request_http_method)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="allowStaticCreds")
    def allow_static_creds(self) -> Optional[_builtins.bool]:
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        return pulumi.get(self, "allow_static_creds")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultDynamicSecretSpecDestination']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount path of the secret's engine in Vault.
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="renewalPercent")
    def renewal_percent(self) -> Optional[_builtins.int]:
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        return pulumi.get(self, "renewal_percent")

    @_builtins.property
    @pulumi.getter(name="requestHTTPMethod")
    def request_http_method(self) -> Optional[_builtins.str]:
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        return pulumi.get(self, "request_http_method")

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[_builtins.bool]:
        """
        Revoke the existing lease on VDS resource deletion.
        """
        return pulumi.get(self, "revoke")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultDynamicSecretSpecRolloutRestartTargets']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")


@pulumi.output_type
class VaultDynamicSecretSpecDestination(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultDynamicSecretSpecDestinationPatch(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultDynamicSecretSpecPatch(dict):
    """
    VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowStaticCreds":
            suggest = "allow_static_creds"
        elif key == "renewalPercent":
            suggest = "renewal_percent"
        elif key == "requestHTTPMethod":
            suggest = "request_http_method"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_static_creds: Optional[_builtins.bool] = None,
                 destination: Optional['outputs.VaultDynamicSecretSpecDestinationPatch'] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 params: Optional[Mapping[str, _builtins.str]] = None,
                 path: Optional[_builtins.str] = None,
                 renewal_percent: Optional[_builtins.int] = None,
                 request_http_method: Optional[_builtins.str] = None,
                 revoke: Optional[_builtins.bool] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultDynamicSecretSpecRolloutRestartTargetsPatch']] = None,
                 vault_auth_ref: Optional[_builtins.str] = None):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        :param _builtins.bool allow_static_creds: AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        :param _builtins.str mount: Mount path of the secret's engine in Vault.
        :param _builtins.str namespace: Namespace where the secrets engine is mounted in Vault.
        :param Mapping[str, _builtins.str] params: Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        :param _builtins.str path: Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        :param _builtins.int renewal_percent: RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        :param _builtins.str request_http_method: RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        :param _builtins.bool revoke: Revoke the existing lease on VDS resource deletion.
        :param Sequence['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if allow_static_creds is not None:
            pulumi.set(__self__, "allow_static_creds", allow_static_creds)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if renewal_percent is not None:
            pulumi.set(__self__, "renewal_percent", renewal_percent)
        if request_http_method is not None:
            pulumi.set(__self__, "request_http_method", request_http_method)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="allowStaticCreds")
    def allow_static_creds(self) -> Optional[_builtins.bool]:
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        return pulumi.get(self, "allow_static_creds")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultDynamicSecretSpecDestinationPatch']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount path of the secret's engine in Vault.
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        return pulumi.get(self, "params")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="renewalPercent")
    def renewal_percent(self) -> Optional[_builtins.int]:
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        return pulumi.get(self, "renewal_percent")

    @_builtins.property
    @pulumi.getter(name="requestHTTPMethod")
    def request_http_method(self) -> Optional[_builtins.str]:
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        return pulumi.get(self, "request_http_method")

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[_builtins.bool]:
        """
        Revoke the existing lease on VDS resource deletion.
        """
        return pulumi.get(self, "revoke")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultDynamicSecretSpecRolloutRestartTargetsPatch']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")


@pulumi.output_type
class VaultDynamicSecretSpecRolloutRestartTargets(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultDynamicSecretSpecRolloutRestartTargetsPatch(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultDynamicSecretStatus(dict):
    """
    VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastGeneration":
            suggest = "last_generation"
        elif key == "lastRenewalTime":
            suggest = "last_renewal_time"
        elif key == "lastRuntimePodUID":
            suggest = "last_runtime_pod_uid"
        elif key == "secretLease":
            suggest = "secret_lease"
        elif key == "secretMAC":
            suggest = "secret_mac"
        elif key == "staticCredsMetaData":
            suggest = "static_creds_meta_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_generation: Optional[_builtins.int] = None,
                 last_renewal_time: Optional[_builtins.int] = None,
                 last_runtime_pod_uid: Optional[_builtins.str] = None,
                 secret_lease: Optional['outputs.VaultDynamicSecretStatusSecretLease'] = None,
                 secret_mac: Optional[_builtins.str] = None,
                 static_creds_meta_data: Optional['outputs.VaultDynamicSecretStatusStaticCredsMetaData'] = None):
        """
        VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
        :param _builtins.int last_generation: LastGeneration is the Generation of the last reconciled resource.
        :param _builtins.int last_renewal_time: LastRenewalTime of the last successful secret lease renewal.
        :param _builtins.str last_runtime_pod_uid: LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        :param _builtins.str secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        if last_generation is not None:
            pulumi.set(__self__, "last_generation", last_generation)
        if last_renewal_time is not None:
            pulumi.set(__self__, "last_renewal_time", last_renewal_time)
        if last_runtime_pod_uid is not None:
            pulumi.set(__self__, "last_runtime_pod_uid", last_runtime_pod_uid)
        if secret_lease is not None:
            pulumi.set(__self__, "secret_lease", secret_lease)
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)
        if static_creds_meta_data is not None:
            pulumi.set(__self__, "static_creds_meta_data", static_creds_meta_data)

    @_builtins.property
    @pulumi.getter(name="lastGeneration")
    def last_generation(self) -> Optional[_builtins.int]:
        """
        LastGeneration is the Generation of the last reconciled resource.
        """
        return pulumi.get(self, "last_generation")

    @_builtins.property
    @pulumi.getter(name="lastRenewalTime")
    def last_renewal_time(self) -> Optional[_builtins.int]:
        """
        LastRenewalTime of the last successful secret lease renewal.
        """
        return pulumi.get(self, "last_renewal_time")

    @_builtins.property
    @pulumi.getter(name="lastRuntimePodUID")
    def last_runtime_pod_uid(self) -> Optional[_builtins.str]:
        """
        LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        """
        return pulumi.get(self, "last_runtime_pod_uid")

    @_builtins.property
    @pulumi.getter(name="secretLease")
    def secret_lease(self) -> Optional['outputs.VaultDynamicSecretStatusSecretLease']:
        return pulumi.get(self, "secret_lease")

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[_builtins.str]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        return pulumi.get(self, "secret_mac")

    @_builtins.property
    @pulumi.getter(name="staticCredsMetaData")
    def static_creds_meta_data(self) -> Optional['outputs.VaultDynamicSecretStatusStaticCredsMetaData']:
        return pulumi.get(self, "static_creds_meta_data")


@pulumi.output_type
class VaultDynamicSecretStatusPatch(dict):
    """
    VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastGeneration":
            suggest = "last_generation"
        elif key == "lastRenewalTime":
            suggest = "last_renewal_time"
        elif key == "lastRuntimePodUID":
            suggest = "last_runtime_pod_uid"
        elif key == "secretLease":
            suggest = "secret_lease"
        elif key == "secretMAC":
            suggest = "secret_mac"
        elif key == "staticCredsMetaData":
            suggest = "static_creds_meta_data"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatusPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatusPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatusPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_generation: Optional[_builtins.int] = None,
                 last_renewal_time: Optional[_builtins.int] = None,
                 last_runtime_pod_uid: Optional[_builtins.str] = None,
                 secret_lease: Optional['outputs.VaultDynamicSecretStatusSecretLeasePatch'] = None,
                 secret_mac: Optional[_builtins.str] = None,
                 static_creds_meta_data: Optional['outputs.VaultDynamicSecretStatusStaticCredsMetaDataPatch'] = None):
        """
        VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
        :param _builtins.int last_generation: LastGeneration is the Generation of the last reconciled resource.
        :param _builtins.int last_renewal_time: LastRenewalTime of the last successful secret lease renewal.
        :param _builtins.str last_runtime_pod_uid: LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        :param _builtins.str secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        if last_generation is not None:
            pulumi.set(__self__, "last_generation", last_generation)
        if last_renewal_time is not None:
            pulumi.set(__self__, "last_renewal_time", last_renewal_time)
        if last_runtime_pod_uid is not None:
            pulumi.set(__self__, "last_runtime_pod_uid", last_runtime_pod_uid)
        if secret_lease is not None:
            pulumi.set(__self__, "secret_lease", secret_lease)
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)
        if static_creds_meta_data is not None:
            pulumi.set(__self__, "static_creds_meta_data", static_creds_meta_data)

    @_builtins.property
    @pulumi.getter(name="lastGeneration")
    def last_generation(self) -> Optional[_builtins.int]:
        """
        LastGeneration is the Generation of the last reconciled resource.
        """
        return pulumi.get(self, "last_generation")

    @_builtins.property
    @pulumi.getter(name="lastRenewalTime")
    def last_renewal_time(self) -> Optional[_builtins.int]:
        """
        LastRenewalTime of the last successful secret lease renewal.
        """
        return pulumi.get(self, "last_renewal_time")

    @_builtins.property
    @pulumi.getter(name="lastRuntimePodUID")
    def last_runtime_pod_uid(self) -> Optional[_builtins.str]:
        """
        LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        """
        return pulumi.get(self, "last_runtime_pod_uid")

    @_builtins.property
    @pulumi.getter(name="secretLease")
    def secret_lease(self) -> Optional['outputs.VaultDynamicSecretStatusSecretLeasePatch']:
        return pulumi.get(self, "secret_lease")

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[_builtins.str]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        return pulumi.get(self, "secret_mac")

    @_builtins.property
    @pulumi.getter(name="staticCredsMetaData")
    def static_creds_meta_data(self) -> Optional['outputs.VaultDynamicSecretStatusStaticCredsMetaDataPatch']:
        return pulumi.get(self, "static_creds_meta_data")


@pulumi.output_type
class VaultDynamicSecretStatusSecretLease(dict):
    """
    SecretLease for the Vault secret.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestID":
            suggest = "request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatusSecretLease. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatusSecretLease.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatusSecretLease.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 renewable: Optional[_builtins.bool] = None,
                 request_id: Optional[_builtins.str] = None):
        """
        SecretLease for the Vault secret.
        :param _builtins.int duration: LeaseDuration of the Vault secret.
        :param _builtins.str id: ID of the Vault secret.
        :param _builtins.bool renewable: Renewable Vault secret lease
        :param _builtins.str request_id: RequestID of the Vault secret request.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if renewable is not None:
            pulumi.set(__self__, "renewable", renewable)
        if request_id is not None:
            pulumi.set(__self__, "request_id", request_id)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        LeaseDuration of the Vault secret.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Vault secret.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def renewable(self) -> Optional[_builtins.bool]:
        """
        Renewable Vault secret lease
        """
        return pulumi.get(self, "renewable")

    @_builtins.property
    @pulumi.getter(name="requestID")
    def request_id(self) -> Optional[_builtins.str]:
        """
        RequestID of the Vault secret request.
        """
        return pulumi.get(self, "request_id")


@pulumi.output_type
class VaultDynamicSecretStatusSecretLeasePatch(dict):
    """
    SecretLease for the Vault secret.
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requestID":
            suggest = "request_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatusSecretLeasePatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatusSecretLeasePatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatusSecretLeasePatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 duration: Optional[_builtins.int] = None,
                 id: Optional[_builtins.str] = None,
                 renewable: Optional[_builtins.bool] = None,
                 request_id: Optional[_builtins.str] = None):
        """
        SecretLease for the Vault secret.
        :param _builtins.int duration: LeaseDuration of the Vault secret.
        :param _builtins.str id: ID of the Vault secret.
        :param _builtins.bool renewable: Renewable Vault secret lease
        :param _builtins.str request_id: RequestID of the Vault secret request.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if renewable is not None:
            pulumi.set(__self__, "renewable", renewable)
        if request_id is not None:
            pulumi.set(__self__, "request_id", request_id)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.int]:
        """
        LeaseDuration of the Vault secret.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        ID of the Vault secret.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def renewable(self) -> Optional[_builtins.bool]:
        """
        Renewable Vault secret lease
        """
        return pulumi.get(self, "renewable")

    @_builtins.property
    @pulumi.getter(name="requestID")
    def request_id(self) -> Optional[_builtins.str]:
        """
        RequestID of the Vault secret request.
        """
        return pulumi.get(self, "request_id")


@pulumi.output_type
class VaultDynamicSecretStatusStaticCredsMetaData(dict):
    """
    StaticCredsMetaData contains the static creds response meta-data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastVaultRotation":
            suggest = "last_vault_rotation"
        elif key == "rotationPeriod":
            suggest = "rotation_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatusStaticCredsMetaData. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatusStaticCredsMetaData.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatusStaticCredsMetaData.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_vault_rotation: Optional[_builtins.int] = None,
                 rotation_period: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        StaticCredsMetaData contains the static creds response meta-data
        :param _builtins.int last_vault_rotation: LastVaultRotation represents the last time Vault rotated the password
        :param _builtins.int rotation_period: RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        :param _builtins.int ttl: TTL is the seconds remaining before the next rotation.
        """
        if last_vault_rotation is not None:
            pulumi.set(__self__, "last_vault_rotation", last_vault_rotation)
        if rotation_period is not None:
            pulumi.set(__self__, "rotation_period", rotation_period)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="lastVaultRotation")
    def last_vault_rotation(self) -> Optional[_builtins.int]:
        """
        LastVaultRotation represents the last time Vault rotated the password
        """
        return pulumi.get(self, "last_vault_rotation")

    @_builtins.property
    @pulumi.getter(name="rotationPeriod")
    def rotation_period(self) -> Optional[_builtins.int]:
        """
        RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        """
        return pulumi.get(self, "rotation_period")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        TTL is the seconds remaining before the next rotation.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class VaultDynamicSecretStatusStaticCredsMetaDataPatch(dict):
    """
    StaticCredsMetaData contains the static creds response meta-data
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastVaultRotation":
            suggest = "last_vault_rotation"
        elif key == "rotationPeriod":
            suggest = "rotation_period"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultDynamicSecretStatusStaticCredsMetaDataPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultDynamicSecretStatusStaticCredsMetaDataPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultDynamicSecretStatusStaticCredsMetaDataPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_vault_rotation: Optional[_builtins.int] = None,
                 rotation_period: Optional[_builtins.int] = None,
                 ttl: Optional[_builtins.int] = None):
        """
        StaticCredsMetaData contains the static creds response meta-data
        :param _builtins.int last_vault_rotation: LastVaultRotation represents the last time Vault rotated the password
        :param _builtins.int rotation_period: RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        :param _builtins.int ttl: TTL is the seconds remaining before the next rotation.
        """
        if last_vault_rotation is not None:
            pulumi.set(__self__, "last_vault_rotation", last_vault_rotation)
        if rotation_period is not None:
            pulumi.set(__self__, "rotation_period", rotation_period)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="lastVaultRotation")
    def last_vault_rotation(self) -> Optional[_builtins.int]:
        """
        LastVaultRotation represents the last time Vault rotated the password
        """
        return pulumi.get(self, "last_vault_rotation")

    @_builtins.property
    @pulumi.getter(name="rotationPeriod")
    def rotation_period(self) -> Optional[_builtins.int]:
        """
        RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        """
        return pulumi.get(self, "rotation_period")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.int]:
        """
        TTL is the seconds remaining before the next rotation.
        """
        return pulumi.get(self, "ttl")


@pulumi.output_type
class VaultPKISecret(dict):
    """
    VaultPKISecret is the Schema for the vaultpkisecrets API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultPKISecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultPKISecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultPKISecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.VaultPKISecretSpec'] = None,
                 status: Optional['outputs.VaultPKISecretStatus'] = None):
        """
        VaultPKISecret is the Schema for the vaultpkisecrets API
        :param _builtins.str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param _builtins.str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultPKISecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.VaultPKISecretSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.VaultPKISecretStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class VaultPKISecretSpec(dict):
    """
    VaultPKISecretSpec defines the desired state of VaultPKISecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "altNames":
            suggest = "alt_names"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "excludeCNFromSans":
            suggest = "exclude_cn_from_sans"
        elif key == "expiryOffset":
            suggest = "expiry_offset"
        elif key == "ipSans":
            suggest = "ip_sans"
        elif key == "issuerRef":
            suggest = "issuer_ref"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "otherSans":
            suggest = "other_sans"
        elif key == "privateKeyFormat":
            suggest = "private_key_format"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "uriSans":
            suggest = "uri_sans"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultPKISecretSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultPKISecretSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultPKISecretSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alt_names: Optional[Sequence[_builtins.str]] = None,
                 clear: Optional[_builtins.bool] = None,
                 common_name: Optional[_builtins.str] = None,
                 destination: Optional['outputs.VaultPKISecretSpecDestination'] = None,
                 exclude_cn_from_sans: Optional[_builtins.bool] = None,
                 expiry_offset: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 ip_sans: Optional[Sequence[_builtins.str]] = None,
                 issuer_ref: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 not_after: Optional[_builtins.str] = None,
                 other_sans: Optional[Sequence[_builtins.str]] = None,
                 private_key_format: Optional[_builtins.str] = None,
                 revoke: Optional[_builtins.bool] = None,
                 role: Optional[_builtins.str] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultPKISecretSpecRolloutRestartTargets']] = None,
                 ttl: Optional[_builtins.str] = None,
                 uri_sans: Optional[Sequence[_builtins.str]] = None,
                 vault_auth_ref: Optional[_builtins.str] = None):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        :param Sequence[_builtins.str] alt_names: AltNames to include in the request May contain both DNS names and email addresses.
        :param _builtins.bool clear: Clear the Kubernetes secret when the resource is deleted.
        :param _builtins.str common_name: CommonName to include in the request.
        :param _builtins.bool exclude_cn_from_sans: ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        :param _builtins.str expiry_offset: ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        :param _builtins.str format: Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        :param Sequence[_builtins.str] ip_sans: IPSans to include in the request.
        :param _builtins.str issuer_ref: IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        :param _builtins.str mount: Mount for the secret in Vault
        :param _builtins.str namespace: Namespace to get the secret from in Vault
        :param _builtins.str not_after: NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        :param Sequence[_builtins.str] other_sans: Requested other SANs, in an array with the format oid;type:value for each entry.
        :param _builtins.str private_key_format: PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        :param _builtins.bool revoke: Revoke the certificate when the resource is deleted.
        :param _builtins.str role: Role in Vault to use when issuing TLS certificates.
        :param Sequence['VaultPKISecretSpecRolloutRestartTargetsArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param _builtins.str ttl: TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        :param Sequence[_builtins.str] uri_sans: The requested URI SANs.
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if clear is not None:
            pulumi.set(__self__, "clear", clear)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if exclude_cn_from_sans is not None:
            pulumi.set(__self__, "exclude_cn_from_sans", exclude_cn_from_sans)
        if expiry_offset is not None:
            pulumi.set(__self__, "expiry_offset", expiry_offset)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if ip_sans is not None:
            pulumi.set(__self__, "ip_sans", ip_sans)
        if issuer_ref is not None:
            pulumi.set(__self__, "issuer_ref", issuer_ref)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if other_sans is not None:
            pulumi.set(__self__, "other_sans", other_sans)
        if private_key_format is not None:
            pulumi.set(__self__, "private_key_format", private_key_format)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if uri_sans is not None:
            pulumi.set(__self__, "uri_sans", uri_sans)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        return pulumi.get(self, "alt_names")

    @_builtins.property
    @pulumi.getter
    def clear(self) -> Optional[_builtins.bool]:
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        return pulumi.get(self, "clear")

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[_builtins.str]:
        """
        CommonName to include in the request.
        """
        return pulumi.get(self, "common_name")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultPKISecretSpecDestination']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="excludeCNFromSans")
    def exclude_cn_from_sans(self) -> Optional[_builtins.bool]:
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        return pulumi.get(self, "exclude_cn_from_sans")

    @_builtins.property
    @pulumi.getter(name="expiryOffset")
    def expiry_offset(self) -> Optional[_builtins.str]:
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        return pulumi.get(self, "expiry_offset")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="ipSans")
    def ip_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPSans to include in the request.
        """
        return pulumi.get(self, "ip_sans")

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> Optional[_builtins.str]:
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        return pulumi.get(self, "issuer_ref")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[_builtins.str]:
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter(name="otherSans")
    def other_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        return pulumi.get(self, "other_sans")

    @_builtins.property
    @pulumi.getter(name="privateKeyFormat")
    def private_key_format(self) -> Optional[_builtins.str]:
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        return pulumi.get(self, "private_key_format")

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[_builtins.bool]:
        """
        Revoke the certificate when the resource is deleted.
        """
        return pulumi.get(self, "revoke")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role in Vault to use when issuing TLS certificates.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultPKISecretSpecRolloutRestartTargets']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="uriSans")
    def uri_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        The requested URI SANs.
        """
        return pulumi.get(self, "uri_sans")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")


@pulumi.output_type
class VaultPKISecretSpecDestination(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultPKISecretSpecDestinationPatch(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultPKISecretSpecPatch(dict):
    """
    VaultPKISecretSpec defines the desired state of VaultPKISecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "altNames":
            suggest = "alt_names"
        elif key == "commonName":
            suggest = "common_name"
        elif key == "excludeCNFromSans":
            suggest = "exclude_cn_from_sans"
        elif key == "expiryOffset":
            suggest = "expiry_offset"
        elif key == "ipSans":
            suggest = "ip_sans"
        elif key == "issuerRef":
            suggest = "issuer_ref"
        elif key == "notAfter":
            suggest = "not_after"
        elif key == "otherSans":
            suggest = "other_sans"
        elif key == "privateKeyFormat":
            suggest = "private_key_format"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "uriSans":
            suggest = "uri_sans"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultPKISecretSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultPKISecretSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultPKISecretSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 alt_names: Optional[Sequence[_builtins.str]] = None,
                 clear: Optional[_builtins.bool] = None,
                 common_name: Optional[_builtins.str] = None,
                 destination: Optional['outputs.VaultPKISecretSpecDestinationPatch'] = None,
                 exclude_cn_from_sans: Optional[_builtins.bool] = None,
                 expiry_offset: Optional[_builtins.str] = None,
                 format: Optional[_builtins.str] = None,
                 ip_sans: Optional[Sequence[_builtins.str]] = None,
                 issuer_ref: Optional[_builtins.str] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 not_after: Optional[_builtins.str] = None,
                 other_sans: Optional[Sequence[_builtins.str]] = None,
                 private_key_format: Optional[_builtins.str] = None,
                 revoke: Optional[_builtins.bool] = None,
                 role: Optional[_builtins.str] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultPKISecretSpecRolloutRestartTargetsPatch']] = None,
                 ttl: Optional[_builtins.str] = None,
                 uri_sans: Optional[Sequence[_builtins.str]] = None,
                 vault_auth_ref: Optional[_builtins.str] = None):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        :param Sequence[_builtins.str] alt_names: AltNames to include in the request May contain both DNS names and email addresses.
        :param _builtins.bool clear: Clear the Kubernetes secret when the resource is deleted.
        :param _builtins.str common_name: CommonName to include in the request.
        :param _builtins.bool exclude_cn_from_sans: ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        :param _builtins.str expiry_offset: ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        :param _builtins.str format: Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        :param Sequence[_builtins.str] ip_sans: IPSans to include in the request.
        :param _builtins.str issuer_ref: IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        :param _builtins.str mount: Mount for the secret in Vault
        :param _builtins.str namespace: Namespace to get the secret from in Vault
        :param _builtins.str not_after: NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        :param Sequence[_builtins.str] other_sans: Requested other SANs, in an array with the format oid;type:value for each entry.
        :param _builtins.str private_key_format: PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        :param _builtins.bool revoke: Revoke the certificate when the resource is deleted.
        :param _builtins.str role: Role in Vault to use when issuing TLS certificates.
        :param Sequence['VaultPKISecretSpecRolloutRestartTargetsPatchArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param _builtins.str ttl: TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        :param Sequence[_builtins.str] uri_sans: The requested URI SANs.
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if clear is not None:
            pulumi.set(__self__, "clear", clear)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if exclude_cn_from_sans is not None:
            pulumi.set(__self__, "exclude_cn_from_sans", exclude_cn_from_sans)
        if expiry_offset is not None:
            pulumi.set(__self__, "expiry_offset", expiry_offset)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if ip_sans is not None:
            pulumi.set(__self__, "ip_sans", ip_sans)
        if issuer_ref is not None:
            pulumi.set(__self__, "issuer_ref", issuer_ref)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if other_sans is not None:
            pulumi.set(__self__, "other_sans", other_sans)
        if private_key_format is not None:
            pulumi.set(__self__, "private_key_format", private_key_format)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if uri_sans is not None:
            pulumi.set(__self__, "uri_sans", uri_sans)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[Sequence[_builtins.str]]:
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        return pulumi.get(self, "alt_names")

    @_builtins.property
    @pulumi.getter
    def clear(self) -> Optional[_builtins.bool]:
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        return pulumi.get(self, "clear")

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[_builtins.str]:
        """
        CommonName to include in the request.
        """
        return pulumi.get(self, "common_name")

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultPKISecretSpecDestinationPatch']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="excludeCNFromSans")
    def exclude_cn_from_sans(self) -> Optional[_builtins.bool]:
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        return pulumi.get(self, "exclude_cn_from_sans")

    @_builtins.property
    @pulumi.getter(name="expiryOffset")
    def expiry_offset(self) -> Optional[_builtins.str]:
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        return pulumi.get(self, "expiry_offset")

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[_builtins.str]:
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        return pulumi.get(self, "format")

    @_builtins.property
    @pulumi.getter(name="ipSans")
    def ip_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        IPSans to include in the request.
        """
        return pulumi.get(self, "ip_sans")

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> Optional[_builtins.str]:
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        return pulumi.get(self, "issuer_ref")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[_builtins.str]:
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        return pulumi.get(self, "not_after")

    @_builtins.property
    @pulumi.getter(name="otherSans")
    def other_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        return pulumi.get(self, "other_sans")

    @_builtins.property
    @pulumi.getter(name="privateKeyFormat")
    def private_key_format(self) -> Optional[_builtins.str]:
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        return pulumi.get(self, "private_key_format")

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[_builtins.bool]:
        """
        Revoke the certificate when the resource is deleted.
        """
        return pulumi.get(self, "revoke")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        Role in Vault to use when issuing TLS certificates.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultPKISecretSpecRolloutRestartTargetsPatch']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[_builtins.str]:
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter(name="uriSans")
    def uri_sans(self) -> Optional[Sequence[_builtins.str]]:
        """
        The requested URI SANs.
        """
        return pulumi.get(self, "uri_sans")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")


@pulumi.output_type
class VaultPKISecretSpecRolloutRestartTargets(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultPKISecretSpecRolloutRestartTargetsPatch(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultPKISecretStatus(dict):
    """
    VaultPKISecretStatus defines the observed state of VaultPKISecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultPKISecretStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultPKISecretStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultPKISecretStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: Optional[_builtins.str] = None,
                 expiration: Optional[_builtins.int] = None,
                 serial_number: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultPKISecretStatus defines the observed state of VaultPKISecret
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultPKISecretStatusPatch(dict):
    """
    VaultPKISecretStatus defines the observed state of VaultPKISecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serialNumber":
            suggest = "serial_number"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultPKISecretStatusPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultPKISecretStatusPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultPKISecretStatusPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 error: Optional[_builtins.str] = None,
                 expiration: Optional[_builtins.int] = None,
                 serial_number: Optional[_builtins.str] = None,
                 valid: Optional[_builtins.bool] = None):
        """
        VaultPKISecretStatus defines the observed state of VaultPKISecret
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "error")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "serial_number")

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "valid")


@pulumi.output_type
class VaultStaticSecret(dict):
    """
    VaultStaticSecret is the Schema for the vaultstaticsecrets API
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiVersion":
            suggest = "api_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultStaticSecret. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultStaticSecret.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultStaticSecret.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_version: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 metadata: Optional['_meta.v1.outputs.ObjectMeta'] = None,
                 spec: Optional['outputs.VaultStaticSecretSpec'] = None,
                 status: Optional['outputs.VaultStaticSecretStatus'] = None):
        """
        VaultStaticSecret is the Schema for the vaultstaticsecrets API
        :param _builtins.str api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param _builtins.str kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param '_meta.v1.ObjectMetaArgs' metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultStaticSecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[_builtins.str]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional['_meta.v1.outputs.ObjectMeta']:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional['outputs.VaultStaticSecretSpec']:
        return pulumi.get(self, "spec")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional['outputs.VaultStaticSecretStatus']:
        return pulumi.get(self, "status")


@pulumi.output_type
class VaultStaticSecretSpec(dict):
    """
    VaultStaticSecretSpec defines the desired state of VaultStaticSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacSecretData":
            suggest = "hmac_secret_data"
        elif key == "refreshAfter":
            suggest = "refresh_after"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultStaticSecretSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultStaticSecretSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultStaticSecretSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.VaultStaticSecretSpecDestination'] = None,
                 hmac_secret_data: Optional[_builtins.bool] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 refresh_after: Optional[_builtins.str] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultStaticSecretSpecRolloutRestartTargets']] = None,
                 type: Optional[_builtins.str] = None,
                 vault_auth_ref: Optional[_builtins.str] = None,
                 version: Optional[_builtins.int] = None):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        :param _builtins.bool hmac_secret_data: HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        :param _builtins.str mount: Mount for the secret in Vault
        :param _builtins.str namespace: Namespace to get the secret from in Vault
        :param _builtins.str path: Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        :param _builtins.str refresh_after: RefreshAfter a period of time, in duration notation
        :param Sequence['VaultStaticSecretSpecRolloutRestartTargetsArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        :param _builtins.str type: Type of the Vault static secret
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        :param _builtins.int version: Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if hmac_secret_data is not None:
            pulumi.set(__self__, "hmac_secret_data", hmac_secret_data)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if refresh_after is not None:
            pulumi.set(__self__, "refresh_after", refresh_after)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultStaticSecretSpecDestination']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="hmacSecretData")
    def hmac_secret_data(self) -> Optional[_builtins.bool]:
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        return pulumi.get(self, "hmac_secret_data")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="refreshAfter")
    def refresh_after(self) -> Optional[_builtins.str]:
        """
        RefreshAfter a period of time, in duration notation
        """
        return pulumi.get(self, "refresh_after")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultStaticSecretSpecRolloutRestartTargets']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Vault static secret
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VaultStaticSecretSpecDestination(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultStaticSecretSpecDestinationPatch(dict):
    """
    Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
    """
    def __init__(__self__, *,
                 annotations: Optional[Mapping[str, _builtins.str]] = None,
                 create: Optional[_builtins.bool] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param Mapping[str, _builtins.str] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param _builtins.bool create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param Mapping[str, _builtins.str] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param _builtins.str name: Name of the Secret
        :param _builtins.str type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[_builtins.bool]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VaultStaticSecretSpecPatch(dict):
    """
    VaultStaticSecretSpec defines the desired state of VaultStaticSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hmacSecretData":
            suggest = "hmac_secret_data"
        elif key == "refreshAfter":
            suggest = "refresh_after"
        elif key == "rolloutRestartTargets":
            suggest = "rollout_restart_targets"
        elif key == "vaultAuthRef":
            suggest = "vault_auth_ref"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultStaticSecretSpecPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultStaticSecretSpecPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultStaticSecretSpecPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination: Optional['outputs.VaultStaticSecretSpecDestinationPatch'] = None,
                 hmac_secret_data: Optional[_builtins.bool] = None,
                 mount: Optional[_builtins.str] = None,
                 namespace: Optional[_builtins.str] = None,
                 path: Optional[_builtins.str] = None,
                 refresh_after: Optional[_builtins.str] = None,
                 rollout_restart_targets: Optional[Sequence['outputs.VaultStaticSecretSpecRolloutRestartTargetsPatch']] = None,
                 type: Optional[_builtins.str] = None,
                 vault_auth_ref: Optional[_builtins.str] = None,
                 version: Optional[_builtins.int] = None):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        :param _builtins.bool hmac_secret_data: HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        :param _builtins.str mount: Mount for the secret in Vault
        :param _builtins.str namespace: Namespace to get the secret from in Vault
        :param _builtins.str path: Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        :param _builtins.str refresh_after: RefreshAfter a period of time, in duration notation
        :param Sequence['VaultStaticSecretSpecRolloutRestartTargetsPatchArgs'] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        :param _builtins.str type: Type of the Vault static secret
        :param _builtins.str vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        :param _builtins.int version: Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if hmac_secret_data is not None:
            pulumi.set(__self__, "hmac_secret_data", hmac_secret_data)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if refresh_after is not None:
            pulumi.set(__self__, "refresh_after", refresh_after)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional['outputs.VaultStaticSecretSpecDestinationPatch']:
        return pulumi.get(self, "destination")

    @_builtins.property
    @pulumi.getter(name="hmacSecretData")
    def hmac_secret_data(self) -> Optional[_builtins.bool]:
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        return pulumi.get(self, "hmac_secret_data")

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[_builtins.str]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[_builtins.str]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="refreshAfter")
    def refresh_after(self) -> Optional[_builtins.str]:
        """
        RefreshAfter a period of time, in duration notation
        """
        return pulumi.get(self, "refresh_after")

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[Sequence['outputs.VaultStaticSecretSpecRolloutRestartTargetsPatch']]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Vault static secret
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[_builtins.str]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.int]:
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VaultStaticSecretSpecRolloutRestartTargets(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultStaticSecretSpecRolloutRestartTargetsPatch(dict):
    """
    RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
     Supported resources: Deployment, DaemonSet, StatefulSet
    """
    def __init__(__self__, *,
                 kind: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "name")


@pulumi.output_type
class VaultStaticSecretStatus(dict):
    """
    VaultStaticSecretStatus defines the observed state of VaultStaticSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretMAC":
            suggest = "secret_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultStaticSecretStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultStaticSecretStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultStaticSecretStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_mac: Optional[_builtins.str] = None):
        """
        VaultStaticSecretStatus defines the observed state of VaultStaticSecret
        :param _builtins.str secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[_builtins.str]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        return pulumi.get(self, "secret_mac")


@pulumi.output_type
class VaultStaticSecretStatusPatch(dict):
    """
    VaultStaticSecretStatus defines the observed state of VaultStaticSecret
    """
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretMAC":
            suggest = "secret_mac"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VaultStaticSecretStatusPatch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VaultStaticSecretStatusPatch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VaultStaticSecretStatusPatch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 secret_mac: Optional[_builtins.str] = None):
        """
        VaultStaticSecretStatus defines the observed state of VaultStaticSecret
        :param _builtins.str secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[_builtins.str]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        return pulumi.get(self, "secret_mac")


