# coding=utf-8
# *** WARNING: this file was generated by crd2pulumi. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from ... import _utilities
from ... import meta as _meta

__all__ = [
    'VaultAuthSpecAppRolePatchArgs',
    'VaultAuthSpecAppRolePatchArgsDict',
    'VaultAuthSpecAppRoleArgs',
    'VaultAuthSpecAppRoleArgsDict',
    'VaultAuthSpecAwsPatchArgs',
    'VaultAuthSpecAwsPatchArgsDict',
    'VaultAuthSpecAwsArgs',
    'VaultAuthSpecAwsArgsDict',
    'VaultAuthSpecJwtPatchArgs',
    'VaultAuthSpecJwtPatchArgsDict',
    'VaultAuthSpecJwtArgs',
    'VaultAuthSpecJwtArgsDict',
    'VaultAuthSpecKubernetesPatchArgs',
    'VaultAuthSpecKubernetesPatchArgsDict',
    'VaultAuthSpecKubernetesArgs',
    'VaultAuthSpecKubernetesArgsDict',
    'VaultAuthSpecPatchArgs',
    'VaultAuthSpecPatchArgsDict',
    'VaultAuthSpecStorageEncryptionPatchArgs',
    'VaultAuthSpecStorageEncryptionPatchArgsDict',
    'VaultAuthSpecStorageEncryptionArgs',
    'VaultAuthSpecStorageEncryptionArgsDict',
    'VaultAuthSpecArgs',
    'VaultAuthSpecArgsDict',
    'VaultAuthStatusArgs',
    'VaultAuthStatusArgsDict',
    'VaultAuthArgs',
    'VaultAuthArgsDict',
    'VaultConnectionSpecPatchArgs',
    'VaultConnectionSpecPatchArgsDict',
    'VaultConnectionSpecArgs',
    'VaultConnectionSpecArgsDict',
    'VaultConnectionStatusArgs',
    'VaultConnectionStatusArgsDict',
    'VaultConnectionArgs',
    'VaultConnectionArgsDict',
    'VaultDynamicSecretSpecDestinationPatchArgs',
    'VaultDynamicSecretSpecDestinationPatchArgsDict',
    'VaultDynamicSecretSpecDestinationArgs',
    'VaultDynamicSecretSpecDestinationArgsDict',
    'VaultDynamicSecretSpecPatchArgs',
    'VaultDynamicSecretSpecPatchArgsDict',
    'VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs',
    'VaultDynamicSecretSpecRolloutRestartTargetsPatchArgsDict',
    'VaultDynamicSecretSpecRolloutRestartTargetsArgs',
    'VaultDynamicSecretSpecRolloutRestartTargetsArgsDict',
    'VaultDynamicSecretSpecArgs',
    'VaultDynamicSecretSpecArgsDict',
    'VaultDynamicSecretStatusSecretLeaseArgs',
    'VaultDynamicSecretStatusSecretLeaseArgsDict',
    'VaultDynamicSecretStatusStaticCredsMetaDataArgs',
    'VaultDynamicSecretStatusStaticCredsMetaDataArgsDict',
    'VaultDynamicSecretStatusArgs',
    'VaultDynamicSecretStatusArgsDict',
    'VaultDynamicSecretArgs',
    'VaultDynamicSecretArgsDict',
    'VaultPKISecretSpecDestinationPatchArgs',
    'VaultPKISecretSpecDestinationPatchArgsDict',
    'VaultPKISecretSpecDestinationArgs',
    'VaultPKISecretSpecDestinationArgsDict',
    'VaultPKISecretSpecPatchArgs',
    'VaultPKISecretSpecPatchArgsDict',
    'VaultPKISecretSpecRolloutRestartTargetsPatchArgs',
    'VaultPKISecretSpecRolloutRestartTargetsPatchArgsDict',
    'VaultPKISecretSpecRolloutRestartTargetsArgs',
    'VaultPKISecretSpecRolloutRestartTargetsArgsDict',
    'VaultPKISecretSpecArgs',
    'VaultPKISecretSpecArgsDict',
    'VaultPKISecretStatusArgs',
    'VaultPKISecretStatusArgsDict',
    'VaultPKISecretArgs',
    'VaultPKISecretArgsDict',
    'VaultStaticSecretSpecDestinationPatchArgs',
    'VaultStaticSecretSpecDestinationPatchArgsDict',
    'VaultStaticSecretSpecDestinationArgs',
    'VaultStaticSecretSpecDestinationArgsDict',
    'VaultStaticSecretSpecPatchArgs',
    'VaultStaticSecretSpecPatchArgsDict',
    'VaultStaticSecretSpecRolloutRestartTargetsPatchArgs',
    'VaultStaticSecretSpecRolloutRestartTargetsPatchArgsDict',
    'VaultStaticSecretSpecRolloutRestartTargetsArgs',
    'VaultStaticSecretSpecRolloutRestartTargetsArgsDict',
    'VaultStaticSecretSpecArgs',
    'VaultStaticSecretSpecArgsDict',
    'VaultStaticSecretStatusArgs',
    'VaultStaticSecretStatusArgsDict',
    'VaultStaticSecretArgs',
    'VaultStaticSecretArgsDict',
]

MYPY = False

if not MYPY:
    class VaultAuthSpecAppRolePatchArgsDict(TypedDict):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        """
        role_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
elif False:
    VaultAuthSpecAppRolePatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecAppRolePatchArgs:
    def __init__(__self__, *,
                 role_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        :param pulumi.Input[_builtins.str] role_id: RoleID of the AppRole Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class VaultAuthSpecAppRoleArgsDict(TypedDict):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        """
        role_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
elif False:
    VaultAuthSpecAppRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecAppRoleArgs:
    def __init__(__self__, *,
                 role_id: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AppRole specific auth configuration, requires that the Method be set to `appRole`.
        :param pulumi.Input[_builtins.str] role_id: RoleID of the AppRole Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        if role_id is not None:
            pulumi.set(__self__, "role_id", role_id)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)

    @_builtins.property
    @pulumi.getter(name="roleId")
    def role_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RoleID of the AppRole Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role_id")

    @role_id.setter
    def role_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_id", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the AppRole Role's SecretID. The secret must have a key named `id` which holds the AppRole Role's secretID.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)


if not MYPY:
    class VaultAuthSpecAwsPatchArgsDict(TypedDict):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        """
        header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Vault header value to include in the STS signing request
        """
        iam_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IAM endpoint to use; if not set will use the default
        """
        irsa_service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Region to use for signing the authentication request
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vault role to use for authenticating
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        session_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role session name to use when creating a webidentity provider
        """
        sts_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The STS endpoint to use; if not set will use the default
        """
elif False:
    VaultAuthSpecAwsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecAwsPatchArgs:
    def __init__(__self__, *,
                 header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 iam_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 irsa_service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 session_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sts_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        :param pulumi.Input[_builtins.str] header_value: The Vault header value to include in the STS signing request
        :param pulumi.Input[_builtins.str] iam_endpoint: The IAM endpoint to use; if not set will use the default
        :param pulumi.Input[_builtins.str] irsa_service_account: IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        :param pulumi.Input[_builtins.str] region: AWS Region to use for signing the authentication request
        :param pulumi.Input[_builtins.str] role: Vault role to use for authenticating
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        :param pulumi.Input[_builtins.str] session_name: The role session name to use when creating a webidentity provider
        :param pulumi.Input[_builtins.str] sts_endpoint: The STS endpoint to use; if not set will use the default
        """
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if iam_endpoint is not None:
            pulumi.set(__self__, "iam_endpoint", iam_endpoint)
        if irsa_service_account is not None:
            pulumi.set(__self__, "irsa_service_account", irsa_service_account)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if session_name is not None:
            pulumi.set(__self__, "session_name", session_name)
        if sts_endpoint is not None:
            pulumi.set(__self__, "sts_endpoint", sts_endpoint)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Vault header value to include in the STS signing request
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_value", value)

    @_builtins.property
    @pulumi.getter(name="iamEndpoint")
    def iam_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IAM endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "iam_endpoint")

    @iam_endpoint.setter
    def iam_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="irsaServiceAccount")
    def irsa_service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        return pulumi.get(self, "irsa_service_account")

    @irsa_service_account.setter
    def irsa_service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "irsa_service_account", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Region to use for signing the authentication request
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vault role to use for authenticating
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="sessionName")
    def session_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role session name to use when creating a webidentity provider
        """
        return pulumi.get(self, "session_name")

    @session_name.setter
    def session_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_name", value)

    @_builtins.property
    @pulumi.getter(name="stsEndpoint")
    def sts_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The STS endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "sts_endpoint")

    @sts_endpoint.setter
    def sts_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sts_endpoint", value)


if not MYPY:
    class VaultAuthSpecAwsArgsDict(TypedDict):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        """
        header_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Vault header value to include in the STS signing request
        """
        iam_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IAM endpoint to use; if not set will use the default
        """
        irsa_service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        AWS Region to use for signing the authentication request
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Vault role to use for authenticating
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        session_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role session name to use when creating a webidentity provider
        """
        sts_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        The STS endpoint to use; if not set will use the default
        """
elif False:
    VaultAuthSpecAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecAwsArgs:
    def __init__(__self__, *,
                 header_value: Optional[pulumi.Input[_builtins.str]] = None,
                 iam_endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 irsa_service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 session_name: Optional[pulumi.Input[_builtins.str]] = None,
                 sts_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        AWS specific auth configuration, requires that Method be set to `aws`.
        :param pulumi.Input[_builtins.str] header_value: The Vault header value to include in the STS signing request
        :param pulumi.Input[_builtins.str] iam_endpoint: The IAM endpoint to use; if not set will use the default
        :param pulumi.Input[_builtins.str] irsa_service_account: IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        :param pulumi.Input[_builtins.str] region: AWS Region to use for signing the authentication request
        :param pulumi.Input[_builtins.str] role: Vault role to use for authenticating
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        :param pulumi.Input[_builtins.str] session_name: The role session name to use when creating a webidentity provider
        :param pulumi.Input[_builtins.str] sts_endpoint: The STS endpoint to use; if not set will use the default
        """
        if header_value is not None:
            pulumi.set(__self__, "header_value", header_value)
        if iam_endpoint is not None:
            pulumi.set(__self__, "iam_endpoint", iam_endpoint)
        if irsa_service_account is not None:
            pulumi.set(__self__, "irsa_service_account", irsa_service_account)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if session_name is not None:
            pulumi.set(__self__, "session_name", session_name)
        if sts_endpoint is not None:
            pulumi.set(__self__, "sts_endpoint", sts_endpoint)

    @_builtins.property
    @pulumi.getter(name="headerValue")
    def header_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Vault header value to include in the STS signing request
        """
        return pulumi.get(self, "header_value")

    @header_value.setter
    def header_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "header_value", value)

    @_builtins.property
    @pulumi.getter(name="iamEndpoint")
    def iam_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IAM endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "iam_endpoint")

    @iam_endpoint.setter
    def iam_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "iam_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="irsaServiceAccount")
    def irsa_service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IRSAServiceAccount name to use with IAM Roles for Service Accounts (IRSA), and should be annotated with "eks.amazonaws.com/role-arn". This ServiceAccount will be checked for other EKS annotations: eks.amazonaws.com/audience and eks.amazonaws.com/token-expiration
        """
        return pulumi.get(self, "irsa_service_account")

    @irsa_service_account.setter
    def irsa_service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "irsa_service_account", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        AWS Region to use for signing the authentication request
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Vault role to use for authenticating
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes Secret which holds credentials for AWS. Expected keys include `access_key_id`, `secret_access_key`, `session_token`
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="sessionName")
    def session_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role session name to use when creating a webidentity provider
        """
        return pulumi.get(self, "session_name")

    @session_name.setter
    def session_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_name", value)

    @_builtins.property
    @pulumi.getter(name="stsEndpoint")
    def sts_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The STS endpoint to use; if not set will use the default
        """
        return pulumi.get(self, "sts_endpoint")

    @sts_endpoint.setter
    def sts_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sts_endpoint", value)


if not MYPY:
    class VaultAuthSpecJwtPatchArgsDict(TypedDict):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use for authenticating to Vault.
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        token_expiration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
elif False:
    VaultAuthSpecJwtPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecJwtPatchArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 token_expiration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: TokenAudiences to include in the ServiceAccount token.
        :param pulumi.Input[_builtins.str] role: Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        :param pulumi.Input[_builtins.str] service_account: ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        :param pulumi.Input[_builtins.int] token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")

    @token_expiration_seconds.setter
    def token_expiration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "token_expiration_seconds", value)


if not MYPY:
    class VaultAuthSpecJwtArgsDict(TypedDict):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use for authenticating to Vault.
        """
        secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        token_expiration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
elif False:
    VaultAuthSpecJwtArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecJwtArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 token_expiration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        JWT specific auth configuration, requires that the Method be set to `jwt`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: TokenAudiences to include in the ServiceAccount token.
        :param pulumi.Input[_builtins.str] role: Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] secret_ref: SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        :param pulumi.Input[_builtins.str] service_account: ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        :param pulumi.Input[_builtins.int] token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if secret_ref is not None:
            pulumi.set(__self__, "secret_ref", secret_ref)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="secretRef")
    def secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretRef is the name of a Kubernetes secret in the consumer's (VDS/VSS/PKI) namespace which provides the JWT token to authenticate to Vault's JWT authentication backend. The secret must have a key named `jwt` which holds the JWT token.
        """
        return pulumi.get(self, "secret_ref")

    @secret_ref.setter
    def secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_ref", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ServiceAccount to use when creating a ServiceAccount token to authenticate to Vault's JWT authentication backend.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")

    @token_expiration_seconds.setter
    def token_expiration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "token_expiration_seconds", value)


if not MYPY:
    class VaultAuthSpecKubernetesPatchArgsDict(TypedDict):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use for authenticating to Vault.
        """
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        token_expiration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
elif False:
    VaultAuthSpecKubernetesPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecKubernetesPatchArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 token_expiration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: TokenAudiences to include in the ServiceAccount token.
        :param pulumi.Input[_builtins.str] role: Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] service_account: ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        :param pulumi.Input[_builtins.int] token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")

    @token_expiration_seconds.setter
    def token_expiration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "token_expiration_seconds", value)


if not MYPY:
    class VaultAuthSpecKubernetesArgsDict(TypedDict):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        """
        audiences: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role to use for authenticating to Vault.
        """
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        token_expiration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
elif False:
    VaultAuthSpecKubernetesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecKubernetesArgs:
    def __init__(__self__, *,
                 audiences: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None,
                 token_expiration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        Kubernetes specific auth configuration, requires that the Method be set to `kubernetes`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] audiences: TokenAudiences to include in the ServiceAccount token.
        :param pulumi.Input[_builtins.str] role: Role to use for authenticating to Vault.
        :param pulumi.Input[_builtins.str] service_account: ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        :param pulumi.Input[_builtins.int] token_expiration_seconds: TokenExpirationSeconds to set the ServiceAccount token.
        """
        if audiences is not None:
            pulumi.set(__self__, "audiences", audiences)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)
        if token_expiration_seconds is not None:
            pulumi.set(__self__, "token_expiration_seconds", token_expiration_seconds)

    @_builtins.property
    @pulumi.getter
    def audiences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        TokenAudiences to include in the ServiceAccount token.
        """
        return pulumi.get(self, "audiences")

    @audiences.setter
    def audiences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "audiences", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role to use for authenticating to Vault.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ServiceAccount to use when authenticating to Vault's kubernetes authentication backend.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)

    @_builtins.property
    @pulumi.getter(name="tokenExpirationSeconds")
    def token_expiration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TokenExpirationSeconds to set the ServiceAccount token.
        """
        return pulumi.get(self, "token_expiration_seconds")

    @token_expiration_seconds.setter
    def token_expiration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "token_expiration_seconds", value)


if not MYPY:
    class VaultAuthSpecPatchArgsDict(TypedDict):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        """
        allowed_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        app_role: NotRequired[pulumi.Input['VaultAuthSpecAppRolePatchArgsDict']]
        aws: NotRequired[pulumi.Input['VaultAuthSpecAwsPatchArgsDict']]
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Headers to be included in all Vault requests.
        """
        jwt: NotRequired[pulumi.Input['VaultAuthSpecJwtPatchArgsDict']]
        kubernetes: NotRequired[pulumi.Input['VaultAuthSpecKubernetesPatchArgsDict']]
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Method to use when authenticating to Vault.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount to use when authenticating to auth method.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to auth to in Vault
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Params to use when authenticating to Vault
        """
        storage_encryption: NotRequired[pulumi.Input['VaultAuthSpecStorageEncryptionPatchArgsDict']]
        vault_connection_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
elif False:
    VaultAuthSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecPatchArgs:
    def __init__(__self__, *,
                 allowed_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 app_role: Optional[pulumi.Input['VaultAuthSpecAppRolePatchArgs']] = None,
                 aws: Optional[pulumi.Input['VaultAuthSpecAwsPatchArgs']] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 jwt: Optional[pulumi.Input['VaultAuthSpecJwtPatchArgs']] = None,
                 kubernetes: Optional[pulumi.Input['VaultAuthSpecKubernetesPatchArgs']] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 storage_encryption: Optional[pulumi.Input['VaultAuthSpecStorageEncryptionPatchArgs']] = None,
                 vault_connection_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_namespaces: AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Headers to be included in all Vault requests.
        :param pulumi.Input[_builtins.str] method: Method to use when authenticating to Vault.
        :param pulumi.Input[_builtins.str] mount: Mount to use when authenticating to auth method.
        :param pulumi.Input[_builtins.str] namespace: Namespace to auth to in Vault
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Params to use when authenticating to Vault
        :param pulumi.Input[_builtins.str] vault_connection_ref: VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        if allowed_namespaces is not None:
            pulumi.set(__self__, "allowed_namespaces", allowed_namespaces)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if storage_encryption is not None:
            pulumi.set(__self__, "storage_encryption", storage_encryption)
        if vault_connection_ref is not None:
            pulumi.set(__self__, "vault_connection_ref", vault_connection_ref)

    @_builtins.property
    @pulumi.getter(name="allowedNamespaces")
    def allowed_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        return pulumi.get(self, "allowed_namespaces")

    @allowed_namespaces.setter
    def allowed_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional[pulumi.Input['VaultAuthSpecAppRolePatchArgs']]:
        return pulumi.get(self, "app_role")

    @app_role.setter
    def app_role(self, value: Optional[pulumi.Input['VaultAuthSpecAppRolePatchArgs']]):
        pulumi.set(self, "app_role", value)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['VaultAuthSpecAwsPatchArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['VaultAuthSpecAwsPatchArgs']]):
        pulumi.set(self, "aws", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional[pulumi.Input['VaultAuthSpecJwtPatchArgs']]:
        return pulumi.get(self, "jwt")

    @jwt.setter
    def jwt(self, value: Optional[pulumi.Input['VaultAuthSpecJwtPatchArgs']]):
        pulumi.set(self, "jwt", value)

    @_builtins.property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input['VaultAuthSpecKubernetesPatchArgs']]:
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input['VaultAuthSpecKubernetesPatchArgs']]):
        pulumi.set(self, "kubernetes", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Method to use when authenticating to Vault.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount to use when authenticating to auth method.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to auth to in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Params to use when authenticating to Vault
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter(name="storageEncryption")
    def storage_encryption(self) -> Optional[pulumi.Input['VaultAuthSpecStorageEncryptionPatchArgs']]:
        return pulumi.get(self, "storage_encryption")

    @storage_encryption.setter
    def storage_encryption(self, value: Optional[pulumi.Input['VaultAuthSpecStorageEncryptionPatchArgs']]):
        pulumi.set(self, "storage_encryption", value)

    @_builtins.property
    @pulumi.getter(name="vaultConnectionRef")
    def vault_connection_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_connection_ref")

    @vault_connection_ref.setter
    def vault_connection_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_connection_ref", value)


if not MYPY:
    class VaultAuthSpecStorageEncryptionPatchArgsDict(TypedDict):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount path of the Transit engine in Vault.
        """
elif False:
    VaultAuthSpecStorageEncryptionPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecStorageEncryptionPatchArgs:
    def __init__(__self__, *,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        :param pulumi.Input[_builtins.str] key_name: KeyName to use for encrypt/decrypt operations via Vault Transit.
        :param pulumi.Input[_builtins.str] mount: Mount path of the Transit engine in Vault.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount path of the Transit engine in Vault.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)


if not MYPY:
    class VaultAuthSpecStorageEncryptionArgsDict(TypedDict):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount path of the Transit engine in Vault.
        """
elif False:
    VaultAuthSpecStorageEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecStorageEncryptionArgs:
    def __init__(__self__, *,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None):
        """
        StorageEncryption provides the necessary configuration to encrypt the client storage cache. This should only be configured when client cache persistence with encryption is enabled. This is done by passing setting the manager's commandline argument --client-cache-persistence-model=direct-encrypted. Typically there should only ever be one VaultAuth configured with StorageEncryption in the Cluster, and it should have the label: cacheStorageEncryption=true
        :param pulumi.Input[_builtins.str] key_name: KeyName to use for encrypt/decrypt operations via Vault Transit.
        :param pulumi.Input[_builtins.str] mount: Mount path of the Transit engine in Vault.
        """
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        KeyName to use for encrypt/decrypt operations via Vault Transit.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount path of the Transit engine in Vault.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)


if not MYPY:
    class VaultAuthSpecArgsDict(TypedDict):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        """
        allowed_namespaces: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        app_role: NotRequired[pulumi.Input['VaultAuthSpecAppRoleArgsDict']]
        aws: NotRequired[pulumi.Input['VaultAuthSpecAwsArgsDict']]
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Headers to be included in all Vault requests.
        """
        jwt: NotRequired[pulumi.Input['VaultAuthSpecJwtArgsDict']]
        kubernetes: NotRequired[pulumi.Input['VaultAuthSpecKubernetesArgsDict']]
        method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Method to use when authenticating to Vault.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount to use when authenticating to auth method.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to auth to in Vault
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Params to use when authenticating to Vault
        """
        storage_encryption: NotRequired[pulumi.Input['VaultAuthSpecStorageEncryptionArgsDict']]
        vault_connection_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
elif False:
    VaultAuthSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthSpecArgs:
    def __init__(__self__, *,
                 allowed_namespaces: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 app_role: Optional[pulumi.Input['VaultAuthSpecAppRoleArgs']] = None,
                 aws: Optional[pulumi.Input['VaultAuthSpecAwsArgs']] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 jwt: Optional[pulumi.Input['VaultAuthSpecJwtArgs']] = None,
                 kubernetes: Optional[pulumi.Input['VaultAuthSpecKubernetesArgs']] = None,
                 method: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 storage_encryption: Optional[pulumi.Input['VaultAuthSpecStorageEncryptionArgs']] = None,
                 vault_connection_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultAuthSpec defines the desired state of VaultAuth
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_namespaces: AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Headers to be included in all Vault requests.
        :param pulumi.Input[_builtins.str] method: Method to use when authenticating to Vault.
        :param pulumi.Input[_builtins.str] mount: Mount to use when authenticating to auth method.
        :param pulumi.Input[_builtins.str] namespace: Namespace to auth to in Vault
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Params to use when authenticating to Vault
        :param pulumi.Input[_builtins.str] vault_connection_ref: VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        if allowed_namespaces is not None:
            pulumi.set(__self__, "allowed_namespaces", allowed_namespaces)
        if app_role is not None:
            pulumi.set(__self__, "app_role", app_role)
        if aws is not None:
            pulumi.set(__self__, "aws", aws)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if jwt is not None:
            pulumi.set(__self__, "jwt", jwt)
        if kubernetes is not None:
            pulumi.set(__self__, "kubernetes", kubernetes)
        if method is not None:
            pulumi.set(__self__, "method", method)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if storage_encryption is not None:
            pulumi.set(__self__, "storage_encryption", storage_encryption)
        if vault_connection_ref is not None:
            pulumi.set(__self__, "vault_connection_ref", vault_connection_ref)

    @_builtins.property
    @pulumi.getter(name="allowedNamespaces")
    def allowed_namespaces(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AllowedNamespaces Kubernetes Namespaces which are allow-listed for use with this AuthMethod. This field allows administrators to customize which Kubernetes namespaces are authorized to use with this AuthMethod. While Vault will still enforce its own rules, this has the added configurability of restricting which VaultAuthMethods can be used by which namespaces. Accepted values: []{"*"} - wildcard, all namespaces. []{"a", "b"} - list of namespaces. unset - disallow all namespaces except the Operator's the VaultAuthMethod's namespace, this is the default behavior.
        """
        return pulumi.get(self, "allowed_namespaces")

    @allowed_namespaces.setter
    def allowed_namespaces(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_namespaces", value)

    @_builtins.property
    @pulumi.getter(name="appRole")
    def app_role(self) -> Optional[pulumi.Input['VaultAuthSpecAppRoleArgs']]:
        return pulumi.get(self, "app_role")

    @app_role.setter
    def app_role(self, value: Optional[pulumi.Input['VaultAuthSpecAppRoleArgs']]):
        pulumi.set(self, "app_role", value)

    @_builtins.property
    @pulumi.getter
    def aws(self) -> Optional[pulumi.Input['VaultAuthSpecAwsArgs']]:
        return pulumi.get(self, "aws")

    @aws.setter
    def aws(self, value: Optional[pulumi.Input['VaultAuthSpecAwsArgs']]):
        pulumi.set(self, "aws", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter
    def jwt(self) -> Optional[pulumi.Input['VaultAuthSpecJwtArgs']]:
        return pulumi.get(self, "jwt")

    @jwt.setter
    def jwt(self, value: Optional[pulumi.Input['VaultAuthSpecJwtArgs']]):
        pulumi.set(self, "jwt", value)

    @_builtins.property
    @pulumi.getter
    def kubernetes(self) -> Optional[pulumi.Input['VaultAuthSpecKubernetesArgs']]:
        return pulumi.get(self, "kubernetes")

    @kubernetes.setter
    def kubernetes(self, value: Optional[pulumi.Input['VaultAuthSpecKubernetesArgs']]):
        pulumi.set(self, "kubernetes", value)

    @_builtins.property
    @pulumi.getter
    def method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Method to use when authenticating to Vault.
        """
        return pulumi.get(self, "method")

    @method.setter
    def method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "method", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount to use when authenticating to auth method.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to auth to in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Params to use when authenticating to Vault
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter(name="storageEncryption")
    def storage_encryption(self) -> Optional[pulumi.Input['VaultAuthSpecStorageEncryptionArgs']]:
        return pulumi.get(self, "storage_encryption")

    @storage_encryption.setter
    def storage_encryption(self, value: Optional[pulumi.Input['VaultAuthSpecStorageEncryptionArgs']]):
        pulumi.set(self, "storage_encryption", value)

    @_builtins.property
    @pulumi.getter(name="vaultConnectionRef")
    def vault_connection_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultConnectionRef to the VaultConnection resource, can be prefixed with a namespace, eg: `namespaceA/vaultConnectionRefB`. If no namespace prefix is provided it will default to namespace of the VaultConnection CR. If no value is specified for VaultConnectionRef the Operator will default to	`default` VaultConnection, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_connection_ref")

    @vault_connection_ref.setter
    def vault_connection_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_connection_ref", value)


if not MYPY:
    class VaultAuthStatusArgsDict(TypedDict):
        """
        VaultAuthStatus defines the observed state of VaultAuth
        """
        error: NotRequired[pulumi.Input[_builtins.str]]
        valid: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Valid auth mechanism.
        """
elif False:
    VaultAuthStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthStatusArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input[_builtins.str]] = None,
                 valid: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        VaultAuthStatus defines the observed state of VaultAuth
        :param pulumi.Input[_builtins.bool] valid: Valid auth mechanism.
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class VaultAuthArgsDict(TypedDict):
        """
        VaultAuth is the Schema for the vaultauths API
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['VaultAuthSpecArgsDict']]
        status: NotRequired[pulumi.Input['VaultAuthStatusArgsDict']]
elif False:
    VaultAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultAuthArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['VaultAuthSpecArgs']] = None,
                 status: Optional[pulumi.Input['VaultAuthStatusArgs']] = None):
        """
        VaultAuth is the Schema for the vaultauths API
        :param pulumi.Input[_builtins.str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[_builtins.str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultAuth')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['VaultAuthSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['VaultAuthSpecArgs']]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['VaultAuthStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['VaultAuthStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VaultConnectionSpecPatchArgsDict(TypedDict):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address of the Vault server
        """
        ca_cert_secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Headers to be included in all Vault requests.
        """
        skip_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        SkipTLSVerify for TLS connections.
        """
        tls_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
elif False:
    VaultConnectionSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConnectionSpecPatchArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 ca_cert_secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 skip_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_server_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        :param pulumi.Input[_builtins.str] address: Address of the Vault server
        :param pulumi.Input[_builtins.str] ca_cert_secret_ref: CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Headers to be included in all Vault requests.
        :param pulumi.Input[_builtins.bool] skip_tls_verify: SkipTLSVerify for TLS connections.
        :param pulumi.Input[_builtins.str] tls_server_name: TLSServerName to use as the SNI host for TLS connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_secret_ref is not None:
            pulumi.set(__self__, "ca_cert_secret_ref", ca_cert_secret_ref)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if skip_tls_verify is not None:
            pulumi.set(__self__, "skip_tls_verify", skip_tls_verify)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address of the Vault server
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="caCertSecretRef")
    def ca_cert_secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        return pulumi.get(self, "ca_cert_secret_ref")

    @ca_cert_secret_ref.setter
    def ca_cert_secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_secret_ref", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="skipTLSVerify")
    def skip_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        SkipTLSVerify for TLS connections.
        """
        return pulumi.get(self, "skip_tls_verify")

    @skip_tls_verify.setter
    def skip_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
        return pulumi.get(self, "tls_server_name")

    @tls_server_name.setter
    def tls_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_server_name", value)


if not MYPY:
    class VaultConnectionSpecArgsDict(TypedDict):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        """
        address: NotRequired[pulumi.Input[_builtins.str]]
        """
        Address of the Vault server
        """
        ca_cert_secret_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Headers to be included in all Vault requests.
        """
        skip_tls_verify: NotRequired[pulumi.Input[_builtins.bool]]
        """
        SkipTLSVerify for TLS connections.
        """
        tls_server_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
elif False:
    VaultConnectionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConnectionSpecArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[_builtins.str]] = None,
                 ca_cert_secret_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 skip_tls_verify: Optional[pulumi.Input[_builtins.bool]] = None,
                 tls_server_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultConnectionSpec defines the desired state of VaultConnection
        :param pulumi.Input[_builtins.str] address: Address of the Vault server
        :param pulumi.Input[_builtins.str] ca_cert_secret_ref: CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] headers: Headers to be included in all Vault requests.
        :param pulumi.Input[_builtins.bool] skip_tls_verify: SkipTLSVerify for TLS connections.
        :param pulumi.Input[_builtins.str] tls_server_name: TLSServerName to use as the SNI host for TLS connections.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_secret_ref is not None:
            pulumi.set(__self__, "ca_cert_secret_ref", ca_cert_secret_ref)
        if headers is not None:
            pulumi.set(__self__, "headers", headers)
        if skip_tls_verify is not None:
            pulumi.set(__self__, "skip_tls_verify", skip_tls_verify)
        if tls_server_name is not None:
            pulumi.set(__self__, "tls_server_name", tls_server_name)

    @_builtins.property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Address of the Vault server
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "address", value)

    @_builtins.property
    @pulumi.getter(name="caCertSecretRef")
    def ca_cert_secret_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CACertSecretRef is the name of a Kubernetes secret containing the trusted PEM encoded CA certificate chain as `ca.crt`.
        """
        return pulumi.get(self, "ca_cert_secret_ref")

    @ca_cert_secret_ref.setter
    def ca_cert_secret_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ca_cert_secret_ref", value)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Headers to be included in all Vault requests.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "headers", value)

    @_builtins.property
    @pulumi.getter(name="skipTLSVerify")
    def skip_tls_verify(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        SkipTLSVerify for TLS connections.
        """
        return pulumi.get(self, "skip_tls_verify")

    @skip_tls_verify.setter
    def skip_tls_verify(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "skip_tls_verify", value)

    @_builtins.property
    @pulumi.getter(name="tlsServerName")
    def tls_server_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TLSServerName to use as the SNI host for TLS connections.
        """
        return pulumi.get(self, "tls_server_name")

    @tls_server_name.setter
    def tls_server_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_server_name", value)


if not MYPY:
    class VaultConnectionStatusArgsDict(TypedDict):
        """
        VaultConnectionStatus defines the observed state of VaultConnection
        """
        valid: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Valid auth mechanism.
        """
elif False:
    VaultConnectionStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConnectionStatusArgs:
    def __init__(__self__, *,
                 valid: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        VaultConnectionStatus defines the observed state of VaultConnection
        :param pulumi.Input[_builtins.bool] valid: Valid auth mechanism.
        """
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Valid auth mechanism.
        """
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class VaultConnectionArgsDict(TypedDict):
        """
        VaultConnection is the Schema for the vaultconnections API
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['VaultConnectionSpecArgsDict']]
        status: NotRequired[pulumi.Input['VaultConnectionStatusArgsDict']]
elif False:
    VaultConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultConnectionArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['VaultConnectionSpecArgs']] = None,
                 status: Optional[pulumi.Input['VaultConnectionStatusArgs']] = None):
        """
        VaultConnection is the Schema for the vaultconnections API
        :param pulumi.Input[_builtins.str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[_builtins.str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultConnection')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['VaultConnectionSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['VaultConnectionSpecArgs']]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['VaultConnectionStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['VaultConnectionStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VaultDynamicSecretSpecDestinationPatchArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultDynamicSecretSpecDestinationPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecDestinationPatchArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultDynamicSecretSpecDestinationArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultDynamicSecretSpecDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecDestinationArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultDynamicSecretSpecPatchArgsDict(TypedDict):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        """
        allow_static_creds: NotRequired[pulumi.Input[_builtins.bool]]
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        destination: NotRequired[pulumi.Input['VaultDynamicSecretSpecDestinationPatchArgsDict']]
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount path of the secret's engine in Vault.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        renewal_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        request_http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        revoke: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Revoke the existing lease on VDS resource deletion.
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
elif False:
    VaultDynamicSecretSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecPatchArgs:
    def __init__(__self__, *,
                 allow_static_creds: Optional[pulumi.Input[_builtins.bool]] = None,
                 destination: Optional[pulumi.Input['VaultDynamicSecretSpecDestinationPatchArgs']] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 renewal_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 request_http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 revoke: Optional[pulumi.Input[_builtins.bool]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs']]]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        :param pulumi.Input[_builtins.bool] allow_static_creds: AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        :param pulumi.Input[_builtins.str] mount: Mount path of the secret's engine in Vault.
        :param pulumi.Input[_builtins.str] namespace: Namespace where the secrets engine is mounted in Vault.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        :param pulumi.Input[_builtins.str] path: Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        :param pulumi.Input[_builtins.int] renewal_percent: RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        :param pulumi.Input[_builtins.str] request_http_method: RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        :param pulumi.Input[_builtins.bool] revoke: Revoke the existing lease on VDS resource deletion.
        :param pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if allow_static_creds is not None:
            pulumi.set(__self__, "allow_static_creds", allow_static_creds)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if renewal_percent is not None:
            pulumi.set(__self__, "renewal_percent", renewal_percent)
        if request_http_method is not None:
            pulumi.set(__self__, "request_http_method", request_http_method)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="allowStaticCreds")
    def allow_static_creds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        return pulumi.get(self, "allow_static_creds")

    @allow_static_creds.setter
    def allow_static_creds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_static_creds", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultDynamicSecretSpecDestinationPatchArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultDynamicSecretSpecDestinationPatchArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount path of the secret's engine in Vault.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="renewalPercent")
    def renewal_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        return pulumi.get(self, "renewal_percent")

    @renewal_percent.setter
    def renewal_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "renewal_percent", value)

    @_builtins.property
    @pulumi.getter(name="requestHTTPMethod")
    def request_http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        return pulumi.get(self, "request_http_method")

    @request_http_method.setter
    def request_http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_http_method", value)

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Revoke the existing lease on VDS resource deletion.
        """
        return pulumi.get(self, "revoke")

    @revoke.setter
    def revoke(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "revoke", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)


if not MYPY:
    class VaultDynamicSecretSpecRolloutRestartTargetsPatchArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultDynamicSecretSpecRolloutRestartTargetsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecRolloutRestartTargetsPatchArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultDynamicSecretSpecRolloutRestartTargetsArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultDynamicSecretSpecRolloutRestartTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecRolloutRestartTargetsArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultDynamicSecretSpecArgsDict(TypedDict):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        """
        allow_static_creds: NotRequired[pulumi.Input[_builtins.bool]]
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        destination: NotRequired[pulumi.Input['VaultDynamicSecretSpecDestinationArgsDict']]
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount path of the secret's engine in Vault.
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        params: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        renewal_percent: NotRequired[pulumi.Input[_builtins.int]]
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        request_http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        revoke: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Revoke the existing lease on VDS resource deletion.
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
elif False:
    VaultDynamicSecretSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretSpecArgs:
    def __init__(__self__, *,
                 allow_static_creds: Optional[pulumi.Input[_builtins.bool]] = None,
                 destination: Optional[pulumi.Input['VaultDynamicSecretSpecDestinationArgs']] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 params: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 renewal_percent: Optional[pulumi.Input[_builtins.int]] = None,
                 request_http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 revoke: Optional[pulumi.Input[_builtins.bool]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsArgs']]]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultDynamicSecretSpec defines the desired state of VaultDynamicSecret
        :param pulumi.Input[_builtins.bool] allow_static_creds: AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        :param pulumi.Input[_builtins.str] mount: Mount path of the secret's engine in Vault.
        :param pulumi.Input[_builtins.str] namespace: Namespace where the secrets engine is mounted in Vault.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] params: Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        :param pulumi.Input[_builtins.str] path: Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        :param pulumi.Input[_builtins.int] renewal_percent: RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        :param pulumi.Input[_builtins.str] request_http_method: RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        :param pulumi.Input[_builtins.bool] revoke: Revoke the existing lease on VDS resource deletion.
        :param pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if allow_static_creds is not None:
            pulumi.set(__self__, "allow_static_creds", allow_static_creds)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if params is not None:
            pulumi.set(__self__, "params", params)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if renewal_percent is not None:
            pulumi.set(__self__, "renewal_percent", renewal_percent)
        if request_http_method is not None:
            pulumi.set(__self__, "request_http_method", request_http_method)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="allowStaticCreds")
    def allow_static_creds(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        AllowStaticCreds should be set when syncing credentials that are periodically rotated by the Vault server, rather than created upon request. These secrets are sometimes referred to as "static roles", or "static credentials", with a request path that contains "static-creds".
        """
        return pulumi.get(self, "allow_static_creds")

    @allow_static_creds.setter
    def allow_static_creds(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_static_creds", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultDynamicSecretSpecDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultDynamicSecretSpecDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount path of the secret's engine in Vault.
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace where the secrets engine is mounted in Vault.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Params that can be passed when requesting credentials/secrets. When Params is set the configured RequestHTTPMethod will be ignored. See RequestHTTPMethod for more details. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'params' should/can be set to.
        """
        return pulumi.get(self, "params")

    @params.setter
    def params(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "params", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path in Vault to get the credentials for, and is relative to Mount. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what 'path' should be set to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="renewalPercent")
    def renewal_percent(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        RenewalPercent is the percent out of 100 of the lease duration when the lease is renewed. Defaults to 67 percent plus jitter.
        """
        return pulumi.get(self, "renewal_percent")

    @renewal_percent.setter
    def renewal_percent(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "renewal_percent", value)

    @_builtins.property
    @pulumi.getter(name="requestHTTPMethod")
    def request_http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RequestHTTPMethod to use when syncing Secrets from Vault. Setting a value here is not typically required. If left unset the Operator will make requests using the GET method. In the case where Params are specified the Operator will use the PUT method. Please consult https://developer.hashicorp.com/vault/docs/secrets if you are uncertain about what method to use. Of note, the Vault client treats PUT and POST as being equivalent. The underlying Vault client implementation will always use the PUT method.
        """
        return pulumi.get(self, "request_http_method")

    @request_http_method.setter
    def request_http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_http_method", value)

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Revoke the existing lease on VDS resource deletion.
        """
        return pulumi.get(self, "revoke")

    @revoke.setter
    def revoke(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "revoke", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultDynamicSecretSpecRolloutRestartTargetsArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)


if not MYPY:
    class VaultDynamicSecretStatusSecretLeaseArgsDict(TypedDict):
        """
        SecretLease for the Vault secret.
        """
        duration: NotRequired[pulumi.Input[_builtins.int]]
        """
        LeaseDuration of the Vault secret.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the Vault secret.
        """
        renewable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Renewable Vault secret lease
        """
        request_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        RequestID of the Vault secret request.
        """
elif False:
    VaultDynamicSecretStatusSecretLeaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretStatusSecretLeaseArgs:
    def __init__(__self__, *,
                 duration: Optional[pulumi.Input[_builtins.int]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 renewable: Optional[pulumi.Input[_builtins.bool]] = None,
                 request_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        SecretLease for the Vault secret.
        :param pulumi.Input[_builtins.int] duration: LeaseDuration of the Vault secret.
        :param pulumi.Input[_builtins.str] id: ID of the Vault secret.
        :param pulumi.Input[_builtins.bool] renewable: Renewable Vault secret lease
        :param pulumi.Input[_builtins.str] request_id: RequestID of the Vault secret request.
        """
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if renewable is not None:
            pulumi.set(__self__, "renewable", renewable)
        if request_id is not None:
            pulumi.set(__self__, "request_id", request_id)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LeaseDuration of the Vault secret.
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the Vault secret.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def renewable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Renewable Vault secret lease
        """
        return pulumi.get(self, "renewable")

    @renewable.setter
    def renewable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "renewable", value)

    @_builtins.property
    @pulumi.getter(name="requestID")
    def request_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RequestID of the Vault secret request.
        """
        return pulumi.get(self, "request_id")

    @request_id.setter
    def request_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_id", value)


if not MYPY:
    class VaultDynamicSecretStatusStaticCredsMetaDataArgsDict(TypedDict):
        """
        StaticCredsMetaData contains the static creds response meta-data
        """
        last_vault_rotation: NotRequired[pulumi.Input[_builtins.int]]
        """
        LastVaultRotation represents the last time Vault rotated the password
        """
        rotation_period: NotRequired[pulumi.Input[_builtins.int]]
        """
        RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        """
        ttl: NotRequired[pulumi.Input[_builtins.int]]
        """
        TTL is the seconds remaining before the next rotation.
        """
elif False:
    VaultDynamicSecretStatusStaticCredsMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretStatusStaticCredsMetaDataArgs:
    def __init__(__self__, *,
                 last_vault_rotation: Optional[pulumi.Input[_builtins.int]] = None,
                 rotation_period: Optional[pulumi.Input[_builtins.int]] = None,
                 ttl: Optional[pulumi.Input[_builtins.int]] = None):
        """
        StaticCredsMetaData contains the static creds response meta-data
        :param pulumi.Input[_builtins.int] last_vault_rotation: LastVaultRotation represents the last time Vault rotated the password
        :param pulumi.Input[_builtins.int] rotation_period: RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        :param pulumi.Input[_builtins.int] ttl: TTL is the seconds remaining before the next rotation.
        """
        if last_vault_rotation is not None:
            pulumi.set(__self__, "last_vault_rotation", last_vault_rotation)
        if rotation_period is not None:
            pulumi.set(__self__, "rotation_period", rotation_period)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)

    @_builtins.property
    @pulumi.getter(name="lastVaultRotation")
    def last_vault_rotation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LastVaultRotation represents the last time Vault rotated the password
        """
        return pulumi.get(self, "last_vault_rotation")

    @last_vault_rotation.setter
    def last_vault_rotation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_vault_rotation", value)

    @_builtins.property
    @pulumi.getter(name="rotationPeriod")
    def rotation_period(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        RotationPeriod is number in seconds between each rotation, effectively a "time to live". This value is compared to the LastVaultRotation to determine if a password needs to be rotated
        """
        return pulumi.get(self, "rotation_period")

    @rotation_period.setter
    def rotation_period(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "rotation_period", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        TTL is the seconds remaining before the next rotation.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class VaultDynamicSecretStatusArgsDict(TypedDict):
        """
        VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
        """
        last_generation: NotRequired[pulumi.Input[_builtins.int]]
        """
        LastGeneration is the Generation of the last reconciled resource.
        """
        last_renewal_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        LastRenewalTime of the last successful secret lease renewal.
        """
        last_runtime_pod_uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        """
        secret_lease: NotRequired[pulumi.Input['VaultDynamicSecretStatusSecretLeaseArgsDict']]
        secret_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        static_creds_meta_data: NotRequired[pulumi.Input['VaultDynamicSecretStatusStaticCredsMetaDataArgsDict']]
elif False:
    VaultDynamicSecretStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretStatusArgs:
    def __init__(__self__, *,
                 last_generation: Optional[pulumi.Input[_builtins.int]] = None,
                 last_renewal_time: Optional[pulumi.Input[_builtins.int]] = None,
                 last_runtime_pod_uid: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_lease: Optional[pulumi.Input['VaultDynamicSecretStatusSecretLeaseArgs']] = None,
                 secret_mac: Optional[pulumi.Input[_builtins.str]] = None,
                 static_creds_meta_data: Optional[pulumi.Input['VaultDynamicSecretStatusStaticCredsMetaDataArgs']] = None):
        """
        VaultDynamicSecretStatus defines the observed state of VaultDynamicSecret
        :param pulumi.Input[_builtins.int] last_generation: LastGeneration is the Generation of the last reconciled resource.
        :param pulumi.Input[_builtins.int] last_renewal_time: LastRenewalTime of the last successful secret lease renewal.
        :param pulumi.Input[_builtins.str] last_runtime_pod_uid: LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        :param pulumi.Input[_builtins.str] secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        if last_generation is not None:
            pulumi.set(__self__, "last_generation", last_generation)
        if last_renewal_time is not None:
            pulumi.set(__self__, "last_renewal_time", last_renewal_time)
        if last_runtime_pod_uid is not None:
            pulumi.set(__self__, "last_runtime_pod_uid", last_runtime_pod_uid)
        if secret_lease is not None:
            pulumi.set(__self__, "secret_lease", secret_lease)
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)
        if static_creds_meta_data is not None:
            pulumi.set(__self__, "static_creds_meta_data", static_creds_meta_data)

    @_builtins.property
    @pulumi.getter(name="lastGeneration")
    def last_generation(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LastGeneration is the Generation of the last reconciled resource.
        """
        return pulumi.get(self, "last_generation")

    @last_generation.setter
    def last_generation(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_generation", value)

    @_builtins.property
    @pulumi.getter(name="lastRenewalTime")
    def last_renewal_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        LastRenewalTime of the last successful secret lease renewal.
        """
        return pulumi.get(self, "last_renewal_time")

    @last_renewal_time.setter
    def last_renewal_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "last_renewal_time", value)

    @_builtins.property
    @pulumi.getter(name="lastRuntimePodUID")
    def last_runtime_pod_uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        LastRuntimePodUID used for tracking the transition from one Pod to the next. It is used to mitigate the effects of a Vault lease renewal storm.
        """
        return pulumi.get(self, "last_runtime_pod_uid")

    @last_runtime_pod_uid.setter
    def last_runtime_pod_uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_runtime_pod_uid", value)

    @_builtins.property
    @pulumi.getter(name="secretLease")
    def secret_lease(self) -> Optional[pulumi.Input['VaultDynamicSecretStatusSecretLeaseArgs']]:
        return pulumi.get(self, "secret_lease")

    @secret_lease.setter
    def secret_lease(self, value: Optional[pulumi.Input['VaultDynamicSecretStatusSecretLeaseArgs']]):
        pulumi.set(self, "secret_lease", value)

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination. SecretMAC will only be stored when VaultDynamicSecretSpec.AllowStaticCreds is true.
        """
        return pulumi.get(self, "secret_mac")

    @secret_mac.setter
    def secret_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_mac", value)

    @_builtins.property
    @pulumi.getter(name="staticCredsMetaData")
    def static_creds_meta_data(self) -> Optional[pulumi.Input['VaultDynamicSecretStatusStaticCredsMetaDataArgs']]:
        return pulumi.get(self, "static_creds_meta_data")

    @static_creds_meta_data.setter
    def static_creds_meta_data(self, value: Optional[pulumi.Input['VaultDynamicSecretStatusStaticCredsMetaDataArgs']]):
        pulumi.set(self, "static_creds_meta_data", value)


if not MYPY:
    class VaultDynamicSecretArgsDict(TypedDict):
        """
        VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['VaultDynamicSecretSpecArgsDict']]
        status: NotRequired[pulumi.Input['VaultDynamicSecretStatusArgsDict']]
elif False:
    VaultDynamicSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultDynamicSecretArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['VaultDynamicSecretSpecArgs']] = None,
                 status: Optional[pulumi.Input['VaultDynamicSecretStatusArgs']] = None):
        """
        VaultDynamicSecret is the Schema for the vaultdynamicsecrets API
        :param pulumi.Input[_builtins.str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[_builtins.str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultDynamicSecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['VaultDynamicSecretSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['VaultDynamicSecretSpecArgs']]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['VaultDynamicSecretStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['VaultDynamicSecretStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VaultPKISecretSpecDestinationPatchArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultPKISecretSpecDestinationPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecDestinationPatchArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultPKISecretSpecDestinationArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultPKISecretSpecDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecDestinationArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes. If the type is set to "kubernetes.io/tls", "tls.key" will be set to the "private_key" response from Vault, and "tls.crt" will be set to "certificate" + "ca_chain" from the Vault response ("issuing_ca" is used when "ca_chain" is empty). The "remove_roots_from_chain=true" option is used with Vault to exclude the root CA from the Vault response.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultPKISecretSpecPatchArgsDict(TypedDict):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        """
        alt_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        clear: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        common_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        CommonName to include in the request.
        """
        destination: NotRequired[pulumi.Input['VaultPKISecretSpecDestinationPatchArgsDict']]
        exclude_cn_from_sans: NotRequired[pulumi.Input[_builtins.bool]]
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        expiry_offset: NotRequired[pulumi.Input[_builtins.str]]
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        ip_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IPSans to include in the request.
        """
        issuer_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount for the secret in Vault
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to get the secret from in Vault
        """
        not_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        other_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        private_key_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        revoke: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Revoke the certificate when the resource is deleted.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role in Vault to use when issuing TLS certificates.
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsPatchArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        uri_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The requested URI SANs.
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
elif False:
    VaultPKISecretSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecPatchArgs:
    def __init__(__self__, *,
                 alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 clear: Optional[pulumi.Input[_builtins.bool]] = None,
                 common_name: Optional[pulumi.Input[_builtins.str]] = None,
                 destination: Optional[pulumi.Input['VaultPKISecretSpecDestinationPatchArgs']] = None,
                 exclude_cn_from_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiry_offset: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuer_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 not_after: Optional[pulumi.Input[_builtins.str]] = None,
                 other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_key_format: Optional[pulumi.Input[_builtins.str]] = None,
                 revoke: Optional[pulumi.Input[_builtins.bool]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsPatchArgs']]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alt_names: AltNames to include in the request May contain both DNS names and email addresses.
        :param pulumi.Input[_builtins.bool] clear: Clear the Kubernetes secret when the resource is deleted.
        :param pulumi.Input[_builtins.str] common_name: CommonName to include in the request.
        :param pulumi.Input[_builtins.bool] exclude_cn_from_sans: ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        :param pulumi.Input[_builtins.str] expiry_offset: ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        :param pulumi.Input[_builtins.str] format: Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_sans: IPSans to include in the request.
        :param pulumi.Input[_builtins.str] issuer_ref: IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        :param pulumi.Input[_builtins.str] mount: Mount for the secret in Vault
        :param pulumi.Input[_builtins.str] namespace: Namespace to get the secret from in Vault
        :param pulumi.Input[_builtins.str] not_after: NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] other_sans: Requested other SANs, in an array with the format oid;type:value for each entry.
        :param pulumi.Input[_builtins.str] private_key_format: PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        :param pulumi.Input[_builtins.bool] revoke: Revoke the certificate when the resource is deleted.
        :param pulumi.Input[_builtins.str] role: Role in Vault to use when issuing TLS certificates.
        :param pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsPatchArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] ttl: TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] uri_sans: The requested URI SANs.
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if clear is not None:
            pulumi.set(__self__, "clear", clear)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if exclude_cn_from_sans is not None:
            pulumi.set(__self__, "exclude_cn_from_sans", exclude_cn_from_sans)
        if expiry_offset is not None:
            pulumi.set(__self__, "expiry_offset", expiry_offset)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if ip_sans is not None:
            pulumi.set(__self__, "ip_sans", ip_sans)
        if issuer_ref is not None:
            pulumi.set(__self__, "issuer_ref", issuer_ref)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if other_sans is not None:
            pulumi.set(__self__, "other_sans", other_sans)
        if private_key_format is not None:
            pulumi.set(__self__, "private_key_format", private_key_format)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if uri_sans is not None:
            pulumi.set(__self__, "uri_sans", uri_sans)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        return pulumi.get(self, "alt_names")

    @alt_names.setter
    def alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alt_names", value)

    @_builtins.property
    @pulumi.getter
    def clear(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        return pulumi.get(self, "clear")

    @clear.setter
    def clear(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clear", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CommonName to include in the request.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultPKISecretSpecDestinationPatchArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultPKISecretSpecDestinationPatchArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="excludeCNFromSans")
    def exclude_cn_from_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        return pulumi.get(self, "exclude_cn_from_sans")

    @exclude_cn_from_sans.setter
    def exclude_cn_from_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_cn_from_sans", value)

    @_builtins.property
    @pulumi.getter(name="expiryOffset")
    def expiry_offset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        return pulumi.get(self, "expiry_offset")

    @expiry_offset.setter
    def expiry_offset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_offset", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="ipSans")
    def ip_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IPSans to include in the request.
        """
        return pulumi.get(self, "ip_sans")

    @ip_sans.setter
    def ip_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_sans", value)

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        return pulumi.get(self, "issuer_ref")

    @issuer_ref.setter
    def issuer_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer_ref", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_after", value)

    @_builtins.property
    @pulumi.getter(name="otherSans")
    def other_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        return pulumi.get(self, "other_sans")

    @other_sans.setter
    def other_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "other_sans", value)

    @_builtins.property
    @pulumi.getter(name="privateKeyFormat")
    def private_key_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        return pulumi.get(self, "private_key_format")

    @private_key_format.setter
    def private_key_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key_format", value)

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Revoke the certificate when the resource is deleted.
        """
        return pulumi.get(self, "revoke")

    @revoke.setter
    def revoke(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "revoke", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role in Vault to use when issuing TLS certificates.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsPatchArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsPatchArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="uriSans")
    def uri_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The requested URI SANs.
        """
        return pulumi.get(self, "uri_sans")

    @uri_sans.setter
    def uri_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "uri_sans", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)


if not MYPY:
    class VaultPKISecretSpecRolloutRestartTargetsPatchArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultPKISecretSpecRolloutRestartTargetsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecRolloutRestartTargetsPatchArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultPKISecretSpecRolloutRestartTargetsArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultPKISecretSpecRolloutRestartTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecRolloutRestartTargetsArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultPKISecretSpecArgsDict(TypedDict):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        """
        alt_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        clear: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        common_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        CommonName to include in the request.
        """
        destination: NotRequired[pulumi.Input['VaultPKISecretSpecDestinationArgsDict']]
        exclude_cn_from_sans: NotRequired[pulumi.Input[_builtins.bool]]
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        expiry_offset: NotRequired[pulumi.Input[_builtins.str]]
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        ip_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IPSans to include in the request.
        """
        issuer_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount for the secret in Vault
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to get the secret from in Vault
        """
        not_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        other_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        private_key_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        revoke: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Revoke the certificate when the resource is deleted.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Role in Vault to use when issuing TLS certificates.
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        uri_sans: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The requested URI SANs.
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
elif False:
    VaultPKISecretSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretSpecArgs:
    def __init__(__self__, *,
                 alt_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 clear: Optional[pulumi.Input[_builtins.bool]] = None,
                 common_name: Optional[pulumi.Input[_builtins.str]] = None,
                 destination: Optional[pulumi.Input['VaultPKISecretSpecDestinationArgs']] = None,
                 exclude_cn_from_sans: Optional[pulumi.Input[_builtins.bool]] = None,
                 expiry_offset: Optional[pulumi.Input[_builtins.str]] = None,
                 format: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 issuer_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 not_after: Optional[pulumi.Input[_builtins.str]] = None,
                 other_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 private_key_format: Optional[pulumi.Input[_builtins.str]] = None,
                 revoke: Optional[pulumi.Input[_builtins.bool]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsArgs']]]] = None,
                 ttl: Optional[pulumi.Input[_builtins.str]] = None,
                 uri_sans: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultPKISecretSpec defines the desired state of VaultPKISecret
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] alt_names: AltNames to include in the request May contain both DNS names and email addresses.
        :param pulumi.Input[_builtins.bool] clear: Clear the Kubernetes secret when the resource is deleted.
        :param pulumi.Input[_builtins.str] common_name: CommonName to include in the request.
        :param pulumi.Input[_builtins.bool] exclude_cn_from_sans: ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        :param pulumi.Input[_builtins.str] expiry_offset: ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        :param pulumi.Input[_builtins.str] format: Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_sans: IPSans to include in the request.
        :param pulumi.Input[_builtins.str] issuer_ref: IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        :param pulumi.Input[_builtins.str] mount: Mount for the secret in Vault
        :param pulumi.Input[_builtins.str] namespace: Namespace to get the secret from in Vault
        :param pulumi.Input[_builtins.str] not_after: NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] other_sans: Requested other SANs, in an array with the format oid;type:value for each entry.
        :param pulumi.Input[_builtins.str] private_key_format: PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        :param pulumi.Input[_builtins.bool] revoke: Revoke the certificate when the resource is deleted.
        :param pulumi.Input[_builtins.str] role: Role in Vault to use when issuing TLS certificates.
        :param pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] ttl: TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] uri_sans: The requested URI SANs.
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        if alt_names is not None:
            pulumi.set(__self__, "alt_names", alt_names)
        if clear is not None:
            pulumi.set(__self__, "clear", clear)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if exclude_cn_from_sans is not None:
            pulumi.set(__self__, "exclude_cn_from_sans", exclude_cn_from_sans)
        if expiry_offset is not None:
            pulumi.set(__self__, "expiry_offset", expiry_offset)
        if format is not None:
            pulumi.set(__self__, "format", format)
        if ip_sans is not None:
            pulumi.set(__self__, "ip_sans", ip_sans)
        if issuer_ref is not None:
            pulumi.set(__self__, "issuer_ref", issuer_ref)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if not_after is not None:
            pulumi.set(__self__, "not_after", not_after)
        if other_sans is not None:
            pulumi.set(__self__, "other_sans", other_sans)
        if private_key_format is not None:
            pulumi.set(__self__, "private_key_format", private_key_format)
        if revoke is not None:
            pulumi.set(__self__, "revoke", revoke)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if ttl is not None:
            pulumi.set(__self__, "ttl", ttl)
        if uri_sans is not None:
            pulumi.set(__self__, "uri_sans", uri_sans)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)

    @_builtins.property
    @pulumi.getter(name="altNames")
    def alt_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        AltNames to include in the request May contain both DNS names and email addresses.
        """
        return pulumi.get(self, "alt_names")

    @alt_names.setter
    def alt_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "alt_names", value)

    @_builtins.property
    @pulumi.getter
    def clear(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Clear the Kubernetes secret when the resource is deleted.
        """
        return pulumi.get(self, "clear")

    @clear.setter
    def clear(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "clear", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CommonName to include in the request.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultPKISecretSpecDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultPKISecretSpecDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="excludeCNFromSans")
    def exclude_cn_from_sans(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        ExcludeCNFromSans from DNS or Email Subject Alternate Names. Default: false
        """
        return pulumi.get(self, "exclude_cn_from_sans")

    @exclude_cn_from_sans.setter
    def exclude_cn_from_sans(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "exclude_cn_from_sans", value)

    @_builtins.property
    @pulumi.getter(name="expiryOffset")
    def expiry_offset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ExpiryOffset to use for computing when the certificate should be renewed. The rotation time will be difference between the expiration and the offset. Should be in duration notation e.g. 30s, 120s, etc. Set to empty string "" to prevent certificate rotation.
        """
        return pulumi.get(self, "expiry_offset")

    @expiry_offset.setter
    def expiry_offset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_offset", value)

    @_builtins.property
    @pulumi.getter
    def format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format for the certificate. Choices: "pem", "der", "pem_bundle". If "pem_bundle", any private key and issuing cert will be appended to the certificate pem. If "der", the value will be base64 encoded. Default: pem
        """
        return pulumi.get(self, "format")

    @format.setter
    def format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "format", value)

    @_builtins.property
    @pulumi.getter(name="ipSans")
    def ip_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IPSans to include in the request.
        """
        return pulumi.get(self, "ip_sans")

    @ip_sans.setter
    def ip_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_sans", value)

    @_builtins.property
    @pulumi.getter(name="issuerRef")
    def issuer_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IssuerRef reference to an existing PKI issuer, either by Vault-generated identifier, the literal string default to refer to the currently configured default issuer, or the name assigned to an issuer. This parameter is part of the request URL.
        """
        return pulumi.get(self, "issuer_ref")

    @issuer_ref.setter
    def issuer_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer_ref", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter(name="notAfter")
    def not_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        NotAfter field of the certificate with specified date value. The value format should be given in UTC format YYYY-MM-ddTHH:MM:SSZ
        """
        return pulumi.get(self, "not_after")

    @not_after.setter
    def not_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_after", value)

    @_builtins.property
    @pulumi.getter(name="otherSans")
    def other_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Requested other SANs, in an array with the format oid;type:value for each entry.
        """
        return pulumi.get(self, "other_sans")

    @other_sans.setter
    def other_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "other_sans", value)

    @_builtins.property
    @pulumi.getter(name="privateKeyFormat")
    def private_key_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        PrivateKeyFormat, generally the default will be controlled by the Format parameter as either base64-encoded DER or PEM-encoded DER. However, this can be set to "pkcs8" to have the returned private key contain base64-encoded pkcs8 or PEM-encoded pkcs8 instead. Default: der
        """
        return pulumi.get(self, "private_key_format")

    @private_key_format.setter
    def private_key_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key_format", value)

    @_builtins.property
    @pulumi.getter
    def revoke(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Revoke the certificate when the resource is deleted.
        """
        return pulumi.get(self, "revoke")

    @revoke.setter
    def revoke(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "revoke", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Role in Vault to use when issuing TLS certificates.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultPKISecretSpecRolloutRestartTargetsArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        TTL for the certificate; sets the expiration date. If not specified the Vault role's default, backend default, or system default TTL is used, in that order. Cannot be larger than the mount's max TTL. Note: this only has an effect when generating a CA cert or signing a CA cert, not when generating a CSR for an intermediate CA. Should be in duration notation e.g. 120s, 2h, etc.
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ttl", value)

    @_builtins.property
    @pulumi.getter(name="uriSans")
    def uri_sans(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The requested URI SANs.
        """
        return pulumi.get(self, "uri_sans")

    @uri_sans.setter
    def uri_sans(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "uri_sans", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)


if not MYPY:
    class VaultPKISecretStatusArgsDict(TypedDict):
        """
        VaultPKISecretStatus defines the observed state of VaultPKISecret
        """
        error: NotRequired[pulumi.Input[_builtins.str]]
        expiration: NotRequired[pulumi.Input[_builtins.int]]
        serial_number: NotRequired[pulumi.Input[_builtins.str]]
        valid: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    VaultPKISecretStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretStatusArgs:
    def __init__(__self__, *,
                 error: Optional[pulumi.Input[_builtins.str]] = None,
                 expiration: Optional[pulumi.Input[_builtins.int]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 valid: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        VaultPKISecretStatus defines the observed state of VaultPKISecret
        """
        if error is not None:
            pulumi.set(__self__, "error", error)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if valid is not None:
            pulumi.set(__self__, "valid", valid)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter
    def valid(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "valid")

    @valid.setter
    def valid(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "valid", value)


if not MYPY:
    class VaultPKISecretArgsDict(TypedDict):
        """
        VaultPKISecret is the Schema for the vaultpkisecrets API
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['VaultPKISecretSpecArgsDict']]
        status: NotRequired[pulumi.Input['VaultPKISecretStatusArgsDict']]
elif False:
    VaultPKISecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultPKISecretArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['VaultPKISecretSpecArgs']] = None,
                 status: Optional[pulumi.Input['VaultPKISecretStatusArgs']] = None):
        """
        VaultPKISecret is the Schema for the vaultpkisecrets API
        :param pulumi.Input[_builtins.str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[_builtins.str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultPKISecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['VaultPKISecretSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['VaultPKISecretSpecArgs']]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['VaultPKISecretStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['VaultPKISecretStatusArgs']]):
        pulumi.set(self, "status", value)


if not MYPY:
    class VaultStaticSecretSpecDestinationPatchArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultStaticSecretSpecDestinationPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecDestinationPatchArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultStaticSecretSpecDestinationArgsDict(TypedDict):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        """
        annotations: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        create: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Secret
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
elif False:
    VaultStaticSecretSpecDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecDestinationArgs:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 create: Optional[pulumi.Input[_builtins.bool]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        Destination provides configuration necessary for syncing the Vault secret to Kubernetes.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] annotations: Annotations to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.bool] create: Create the destination Secret. If the Secret already exists this should be set to false.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: Labels to apply to the Secret. Requires Create to be set to true.
        :param pulumi.Input[_builtins.str] name: Name of the Secret
        :param pulumi.Input[_builtins.str] type: Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        if annotations is not None:
            pulumi.set(__self__, "annotations", annotations)
        if create is not None:
            pulumi.set(__self__, "create", create)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Annotations to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "annotations", value)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Create the destination Secret. If the Secret already exists this should be set to false.
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Labels to apply to the Secret. Requires Create to be set to true.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Secret
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Kubernetes Secret. Requires Create to be set to true. Defaults to Opaque.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class VaultStaticSecretSpecPatchArgsDict(TypedDict):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        """
        destination: NotRequired[pulumi.Input['VaultStaticSecretSpecDestinationPatchArgsDict']]
        hmac_secret_data: NotRequired[pulumi.Input[_builtins.bool]]
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount for the secret in Vault
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to get the secret from in Vault
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        refresh_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        RefreshAfter a period of time, in duration notation
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsPatchArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the Vault static secret
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
elif False:
    VaultStaticSecretSpecPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecPatchArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['VaultStaticSecretSpecDestinationPatchArgs']] = None,
                 hmac_secret_data: Optional[pulumi.Input[_builtins.bool]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_after: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsPatchArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        :param pulumi.Input[_builtins.bool] hmac_secret_data: HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        :param pulumi.Input[_builtins.str] mount: Mount for the secret in Vault
        :param pulumi.Input[_builtins.str] namespace: Namespace to get the secret from in Vault
        :param pulumi.Input[_builtins.str] path: Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        :param pulumi.Input[_builtins.str] refresh_after: RefreshAfter a period of time, in duration notation
        :param pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsPatchArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] type: Type of the Vault static secret
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        :param pulumi.Input[_builtins.int] version: Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if hmac_secret_data is not None:
            pulumi.set(__self__, "hmac_secret_data", hmac_secret_data)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if refresh_after is not None:
            pulumi.set(__self__, "refresh_after", refresh_after)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultStaticSecretSpecDestinationPatchArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultStaticSecretSpecDestinationPatchArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecretData")
    def hmac_secret_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        return pulumi.get(self, "hmac_secret_data")

    @hmac_secret_data.setter
    def hmac_secret_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hmac_secret_data", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="refreshAfter")
    def refresh_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RefreshAfter a period of time, in duration notation
        """
        return pulumi.get(self, "refresh_after")

    @refresh_after.setter
    def refresh_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_after", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsPatchArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsPatchArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the Vault static secret
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VaultStaticSecretSpecRolloutRestartTargetsPatchArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultStaticSecretSpecRolloutRestartTargetsPatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecRolloutRestartTargetsPatchArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultStaticSecretSpecRolloutRestartTargetsArgsDict(TypedDict):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        name: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    VaultStaticSecretSpecRolloutRestartTargetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecRolloutRestartTargetsArgs:
    def __init__(__self__, *,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        RolloutRestartTarget provides the configuration required to perform a rollout-restart of the supported resources upon Vault Secret rotation. The rollout-restart is triggered by patching the target resource's 'spec.template.metadata.annotations' to include 'vso.secrets.hashicorp.com/restartedAt' with a timestamp value of when the trigger was executed. E.g. vso.secrets.hashicorp.com/restartedAt: "2023-03-23T13:39:31Z" 
         Supported resources: Deployment, DaemonSet, StatefulSet
        """
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class VaultStaticSecretSpecArgsDict(TypedDict):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        """
        destination: NotRequired[pulumi.Input['VaultStaticSecretSpecDestinationArgsDict']]
        hmac_secret_data: NotRequired[pulumi.Input[_builtins.bool]]
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        mount: NotRequired[pulumi.Input[_builtins.str]]
        """
        Mount for the secret in Vault
        """
        namespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace to get the secret from in Vault
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        refresh_after: NotRequired[pulumi.Input[_builtins.str]]
        """
        RefreshAfter a period of time, in duration notation
        """
        rollout_restart_targets: NotRequired[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsArgsDict']]]]
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the Vault static secret
        """
        vault_auth_ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
elif False:
    VaultStaticSecretSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretSpecArgs:
    def __init__(__self__, *,
                 destination: Optional[pulumi.Input['VaultStaticSecretSpecDestinationArgs']] = None,
                 hmac_secret_data: Optional[pulumi.Input[_builtins.bool]] = None,
                 mount: Optional[pulumi.Input[_builtins.str]] = None,
                 namespace: Optional[pulumi.Input[_builtins.str]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 refresh_after: Optional[pulumi.Input[_builtins.str]] = None,
                 rollout_restart_targets: Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsArgs']]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 vault_auth_ref: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        VaultStaticSecretSpec defines the desired state of VaultStaticSecret
        :param pulumi.Input[_builtins.bool] hmac_secret_data: HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        :param pulumi.Input[_builtins.str] mount: Mount for the secret in Vault
        :param pulumi.Input[_builtins.str] namespace: Namespace to get the secret from in Vault
        :param pulumi.Input[_builtins.str] path: Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        :param pulumi.Input[_builtins.str] refresh_after: RefreshAfter a period of time, in duration notation
        :param pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsArgs']]] rollout_restart_targets: RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        :param pulumi.Input[_builtins.str] type: Type of the Vault static secret
        :param pulumi.Input[_builtins.str] vault_auth_ref: VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        :param pulumi.Input[_builtins.int] version: Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        if destination is not None:
            pulumi.set(__self__, "destination", destination)
        if hmac_secret_data is not None:
            pulumi.set(__self__, "hmac_secret_data", hmac_secret_data)
        if mount is not None:
            pulumi.set(__self__, "mount", mount)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if refresh_after is not None:
            pulumi.set(__self__, "refresh_after", refresh_after)
        if rollout_restart_targets is not None:
            pulumi.set(__self__, "rollout_restart_targets", rollout_restart_targets)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if vault_auth_ref is not None:
            pulumi.set(__self__, "vault_auth_ref", vault_auth_ref)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def destination(self) -> Optional[pulumi.Input['VaultStaticSecretSpecDestinationArgs']]:
        return pulumi.get(self, "destination")

    @destination.setter
    def destination(self, value: Optional[pulumi.Input['VaultStaticSecretSpecDestinationArgs']]):
        pulumi.set(self, "destination", value)

    @_builtins.property
    @pulumi.getter(name="hmacSecretData")
    def hmac_secret_data(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        HMACSecretData determines whether the Operator computes the HMAC of the Secret's data. The MAC value will be stored in the resource's Status.SecretMac field, and will be used for drift detection and during incoming Vault secret comparison. Enabling this feature is recommended to ensure that Secret's data stays consistent with Vault.
        """
        return pulumi.get(self, "hmac_secret_data")

    @hmac_secret_data.setter
    def hmac_secret_data(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "hmac_secret_data", value)

    @_builtins.property
    @pulumi.getter
    def mount(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Mount for the secret in Vault
        """
        return pulumi.get(self, "mount")

    @mount.setter
    def mount(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mount", value)

    @_builtins.property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace to get the secret from in Vault
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "namespace", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Path of the secret in Vault, corresponds to the `path` parameter for, kv-v1: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v1#read-secret kv-v2: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#read-secret-version
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="refreshAfter")
    def refresh_after(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RefreshAfter a period of time, in duration notation
        """
        return pulumi.get(self, "refresh_after")

    @refresh_after.setter
    def refresh_after(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "refresh_after", value)

    @_builtins.property
    @pulumi.getter(name="rolloutRestartTargets")
    def rollout_restart_targets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsArgs']]]]:
        """
        RolloutRestartTargets should be configured whenever the application(s) consuming the Vault secret does not support dynamically reloading a rotated secret. In that case one, or more RolloutRestartTarget(s) can be configured here. The Operator will trigger a "rollout-restart" for each target whenever the Vault secret changes between reconciliation events. All configured targets wil be ignored if HMACSecretData is set to false. See RolloutRestartTarget for more details.
        """
        return pulumi.get(self, "rollout_restart_targets")

    @rollout_restart_targets.setter
    def rollout_restart_targets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VaultStaticSecretSpecRolloutRestartTargetsArgs']]]]):
        pulumi.set(self, "rollout_restart_targets", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the Vault static secret
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="vaultAuthRef")
    def vault_auth_ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VaultAuthRef to the VaultAuth resource, can be prefixed with a namespace, eg: `namespaceA/vaultAuthRefB`. If no namespace prefix is provided it will default to namespace of the VaultAuth CR. If no value is specified for VaultAuthRef the Operator will default to the `default` VaultAuth, configured in its own Kubernetes namespace.
        """
        return pulumi.get(self, "vault_auth_ref")

    @vault_auth_ref.setter
    def vault_auth_ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vault_auth_ref", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Version of the secret to fetch. Only valid for type kv-v2. Corresponds to version query parameter: https://developer.hashicorp.com/vault/api-docs/secret/kv/kv-v2#version
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class VaultStaticSecretStatusArgsDict(TypedDict):
        """
        VaultStaticSecretStatus defines the observed state of VaultStaticSecret
        """
        secret_mac: NotRequired[pulumi.Input[_builtins.str]]
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
elif False:
    VaultStaticSecretStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretStatusArgs:
    def __init__(__self__, *,
                 secret_mac: Optional[pulumi.Input[_builtins.str]] = None):
        """
        VaultStaticSecretStatus defines the observed state of VaultStaticSecret
        :param pulumi.Input[_builtins.str] secret_mac: SecretMAC used when deciding whether new Vault secret data should be synced. 
                The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
                The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        if secret_mac is not None:
            pulumi.set(__self__, "secret_mac", secret_mac)

    @_builtins.property
    @pulumi.getter(name="secretMAC")
    def secret_mac(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        SecretMAC used when deciding whether new Vault secret data should be synced. 
         The controller will compare the "new" Vault secret data to this value using HMAC, if they are different, then the data will be synced to the Destination. 
         The SecretMac is also used to detect drift in the Destination Secret's Data. If drift is detected the data will be synced to the Destination.
        """
        return pulumi.get(self, "secret_mac")

    @secret_mac.setter
    def secret_mac(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_mac", value)


if not MYPY:
    class VaultStaticSecretArgsDict(TypedDict):
        """
        VaultStaticSecret is the Schema for the vaultstaticsecrets API
        """
        api_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        metadata: NotRequired[pulumi.Input['_meta.v1.ObjectMetaArgsDict']]
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        spec: NotRequired[pulumi.Input['VaultStaticSecretSpecArgsDict']]
        status: NotRequired[pulumi.Input['VaultStaticSecretStatusArgsDict']]
elif False:
    VaultStaticSecretArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VaultStaticSecretArgs:
    def __init__(__self__, *,
                 api_version: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']] = None,
                 spec: Optional[pulumi.Input['VaultStaticSecretSpecArgs']] = None,
                 status: Optional[pulumi.Input['VaultStaticSecretStatusArgs']] = None):
        """
        VaultStaticSecret is the Schema for the vaultstaticsecrets API
        :param pulumi.Input[_builtins.str] api_version: APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        :param pulumi.Input[_builtins.str] kind: Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        :param pulumi.Input['_meta.v1.ObjectMetaArgs'] metadata: Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        if api_version is not None:
            pulumi.set(__self__, "api_version", 'secrets.hashicorp.com/v1beta1')
        if kind is not None:
            pulumi.set(__self__, "kind", 'VaultStaticSecret')
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if spec is not None:
            pulumi.set(__self__, "spec", spec)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiVersion")
    def api_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources
        """
        return pulumi.get(self, "api_version")

    @api_version.setter
    def api_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_version", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]:
        """
        Standard object's metadata. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input['_meta.v1.ObjectMetaArgs']]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def spec(self) -> Optional[pulumi.Input['VaultStaticSecretSpecArgs']]:
        return pulumi.get(self, "spec")

    @spec.setter
    def spec(self, value: Optional[pulumi.Input['VaultStaticSecretSpecArgs']]):
        pulumi.set(self, "spec", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['VaultStaticSecretStatusArgs']]:
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['VaultStaticSecretStatusArgs']]):
        pulumi.set(self, "status", value)


