# Gemini Collaboration Guide

This document outlines the architectural patterns and conventions used in this repository to ensure effective collaboration with the Gemini CLI agent.

## Core Concepts

This repository uses a GitOps workflow managed by Argo CD in a multi-cluster environment.

1.  **Multi-Cluster Setup:**
    *   **`homelab` (Control Cluster):** This cluster runs the main Argo CD instance. Argo CD `Application` resources are deployed here.
    *   **`capstan` (Main Cluster):** This is the primary workload cluster. Applications are deployed *to* this cluster from the `homelab` cluster.

2.  **Kustomize `base` and `overlays`:**
    *   **`bootstrap/base` & `apps/base`:** These directories contain the generic, environment-agnostic definitions for applications. Each application is typically defined as an Argo CD `Application` manifest.
    *   **`overlays/`:** This directory contains cluster-specific configurations. There is an overlay for `main-cluster` (`capstan`) and `control-cluster` (`homelab`). These overlays use Kustomize to apply patches to the base applications, setting cluster-specific parameters like destinations, namespaces, and resource configurations.

## Application Deployment Workflow

1.  A generic application is defined in a `base` directory (e.g., `bootstrap/base/openbao-auth-config`). This definition is usually an Argo CD `Application` manifest.
2.  To deploy this application to a specific cluster, a reference to its base directory is added to the `resources` list in the corresponding overlay's `kustomization.yaml` (e.g., `overlays/main-cluster/kustomization.yaml`).
3.  Cluster-specific configuration is applied via patches within that same overlay `kustomization.yaml`.

## The "Meta-Patching" Strategy

A key pattern in this repository is patching the sub-resources of a child Argo CD `Application`. A patch in a parent Kustomization (like in an `overlay`) cannot directly target a resource generated by a child `Application`.

The correct method, as seen with the `local-path-provisioner` and `openbao-auth-config` examples, is to **patch the child `Application` itself to inject another Kustomize patch**.

### Example: Patching the `VaultAuth` Resource

**Goal:** The generic `VaultAuth` resource in `bootstrap/base/openbao-auth-config/config/` needs a cluster-specific `mount` path.

1.  **Generic Resource (`base`):** A generic `VaultAuth` manifest exists in the base with placeholder values.
    ```yaml
    # bootstrap/base/openbao-auth-config/config/operator-auth.yaml
    apiVersion: secrets.hashicorp.com/v1beta1
    kind: VaultAuth
    metadata:
      name: operator-auth
    spec:
      mount: placeholder-mount-path
      role: placeholder-role
      # ...
    ```

2.  **The Meta-Patch (`overlay`):** A patch is created in the overlay (e.g., `overlays/main-cluster/patches/patch-auth-config-app-for-mc.yaml`). This patch targets the **`Application`** resource, not the `VaultAuth` resource.
    ```yaml
    # overlays/main-cluster/patches/patch-auth-config-app-for-mc.yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: openbao-auth-config
    spec:
      source:
        kustomize:
          patches:
            - patch: |-
                # This inner patch targets the VaultAuth resource
                apiVersion: secrets.hashicorp.com/v1beta1
                kind: VaultAuth
                metadata:
                  name: operator-auth
                spec:
                  mount: kubernetes_cluster_mc # Specific value for main-cluster
                  kubernetes:
                    role: openbao-secrets-operator
              target:
                kind: VaultAuth
                name: operator-auth
    ```

3.  **Applying the Meta-Patch (`overlay`):** The overlay's `kustomization.yaml` applies this "meta-patch" to the `openbao-auth-config` Application.
    ```yaml
    # overlays/main-cluster/kustomization.yaml
    patches:
      - path: patches/patch-auth-config-app-for-mc.yaml
        target:
          kind: Application
          name: openbao-auth-config
    ```
This correctly injects the cluster-specific values into the sub-resource when Argo CD processes the `openbao-auth-config` application.

## Secret Management

Secrets for applications are managed by the **Vault Secrets Operator** and synced from OpenBao.

*   **`VaultAuth`:** Defines *how* the operator authenticates to OpenBao. These resources are typically deployed in the *operator's namespace* (e.g., `openbao-secrets-operator`). The generic definition for the `VaultAuth` resource is stored in a shared file, `vaultauth-inner-patch.yaml`, and then patched by each `overlay` to provide cluster-specific details.
*   **`VaultStaticSecret`:** Defines *what* secret to sync and *where* to put it. These resources are typically deployed in the *application's namespace* that consumes the secret. It references the `VaultAuth` resource to use for authentication.

## The "Meta-Patching" Strategy

A key pattern in this repository is patching the sub-resources of a child Argo CD `Application`. A patch in a parent Kustomization (like in an `overlay`) cannot directly target a resource generated by a child `Application`.

The correct method is to **patch the child `Application` itself to inject another Kustomize patch**.

### Example: Patching an Application's `VaultAuth` Resource

**Goal:** A generic `VaultAuth` resource, deployed by an application (e.g., `tailscale-operator`), needs a cluster-specific `mount` path.

1.  **Generic `VaultAuth` Definition (`overlays/CLUSTER_NAME/patches/vaultauth-inner-patch.yaml`):**
    The generic `VaultAuth` resource definition is stored in a shared file within each cluster's overlay. This file contains the base `VaultAuth` configuration, with the `mount` path set to the cluster-specific value.

    ```yaml
    # overlays/main-cluster/patches/vaultauth-inner-patch.yaml
    apiVersion: secrets.hashicorp.com/v1beta1
    kind: VaultAuth
    metadata:
      name: operator-auth
    spec:
      mount: kubernetes_cluster_mc # Specific value for main-cluster
      kubernetes:
        role: openbao-secrets-operator
    ```

2.  **The Meta-Patch (`overlays/CLUSTER_NAME/patches/patch-APP_NAME-vaultauth-for-CLUSTER_NAME.yaml`):**
    A patch is created in the overlay that targets the **`Application`** resource (e.g., `tailscale-operator`), not the `VaultAuth` resource directly. This patch injects an *inner Kustomize patch* that then targets the `VaultAuth` resource. This meta-patch must correctly identify the source within `spec.sources` that contains the `VaultAuth` definition.

    ```yaml
    # overlays/main-cluster/patches/patch-tailscale-operator-vaultauth-for-mc.yaml
    apiVersion: argoproj.io/v1alpha1
    kind: Application
    metadata:
      name: tailscale-operator # Name of the ArgoCD Application managing VaultAuth
    spec:
      sources:
        - {} # Placeholder for the first source (e.g., Helm chart), if the Kustomize source is not the first.
        - kustomize: # This targets the second source in this example
            patches:
              - patch: |-
                  # This inner patch targets the VaultAuth resource.
                  # Its content is sourced from overlays/main-cluster/patches/vaultauth-inner-patch.yaml
                  apiVersion: secrets.hashicorp.com/v1beta1
                  kind: VaultAuth
                  metadata:
                    name: operator-auth
                  spec:
                    mount: kubernetes_cluster_mc # Specific value for main-cluster
                    kubernetes:
                      role: openbao-secrets-operator
                target:
                  kind: VaultAuth
                  name: operator-auth
    ```
    **Note:** The `spec.sources` field is a list. The index of the source containing the `VaultAuth` definition must be correctly identified in the meta-patch. If the Kustomize source is the first one, you would use `- kustomize: ...` directly under `spec.sources:`. If it's the second, you'd use `- {}` as a placeholder for the first, then `- kustomize: ...` for the second, and so on.

3.  **Applying the Meta-Patch (`overlays/CLUSTER_NAME/kustomization.yaml`):**
    The overlay's `kustomization.yaml` applies this "meta-patch" to the specific `Application` by name.

    ```yaml
    # overlays/main-cluster/kustomization.yaml
    patches:
      - path: patches/patch-tailscale-operator-vaultauth-for-mc.yaml
        target:
          kind: Application
          name: tailscale-operator
    ```
    This correctly injects the cluster-specific values into the sub-resource when Argo CD processes the `tailscale-operator` application.

## Secret Request (`VaultStaticSecret`)

Once the `VaultAuth` resource is correctly configured and deployed, you can define `VaultStaticSecret` resources within your application's base configuration.

*   **`VaultStaticSecret` Definition (`apps/base/APP_NAME/config/my-secret.yaml`):**
    Define the `VaultStaticSecret` resource within the application's base. This resource specifies *what* secret to sync from OpenBao/Vault and *where* to put it in Kubernetes. It references the `VaultAuth` resource for authentication.

    ```yaml
    # apps/base/my-app/config/my-secret.yaml
    apiVersion: secrets.hashicorp.com/v1beta1
    kind: VaultStaticSecret
    metadata:
      name: my-app-secret
      namespace: my-app-namespace # The namespace where the application runs
    spec:
      vaultAuthRef:
        name: operator-auth # References the VaultAuth resource (e.g., from the Vault Secrets Operator)
      type: Opaque
      secretName: my-app-secret-k8s # The name of the Kubernetes Secret to create
      # ... other fields for path in Vault, version, etc.
    ```
    This `VaultStaticSecret` will be deployed by the application's Argo CD `Application` and will instruct the Vault Secrets Operator to fetch the specified secret from OpenBao/Vault using the `operator-auth` `VaultAuth` configuration. The resulting Kubernetes `Secret` (`my-app-secret-k8s`) will be created in the `my-app-namespace`.
