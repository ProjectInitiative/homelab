# Gemini Collaboration Guide

This document outlines the architectural patterns and conventions used in this repository to ensure effective collaboration with the Gemini CLI agent.

## Core Concepts

This repository uses a GitOps workflow managed by Argo CD in a multi-cluster environment, with the root Application manifests **generated dynamically by Pulumi**.

1.  **Multi-Cluster Setup:**
    *   **`homelab` (Control Cluster):** This cluster runs the main Argo CD instance. Argo CD `Application` resources are deployed here.
    *   **`capstan` (Main Cluster):** This is the primary workload cluster. Applications are deployed *to* this cluster from the `homelab` cluster.

2.  **Pulumi-Generated Manifests:**
    *   **`apps.yaml` & `clusters/*.yaml`:** These are the source of truth. `apps.yaml` acts as a catalog of available applications, while `clusters/*.yaml` defines which applications are deployed to which cluster.
    *   **`pulumi/__main__.py`:** This script processes the catalog and cluster configurations to generate the Argo CD `Application` manifests.
    *   **`manifests/`:** The output directory where the generated YAML manifests are written. These are the files that Argo CD actually watches and syncs.

## Development Workflow

We have migrated away from complex Kustomize overlays and "meta-patching" for root applications. The workflow is now:

1.  **Edit Configuration:** Modify `apps.yaml` to define application logic, or `clusters/<cluster>.yaml` to enable/configure an app for a specific environment.
2.  **Generate Manifests:** The CI/CD pipeline (or local tools) runs the Pulumi script to regenerate the manifests in the `manifests/` directory.
3.  **Review Diffs:**
    *   **PR Comments:** Automated automation posts the diff of the generated manifests to Pull Requests, providing a safeguard against unintended changes.
    *   **Local Testing:** Use local tools (like `pulumi preview` or custom scripts) to verify generation before pushing.

## Secret Management

Secrets for applications are managed by the **Vault Secrets Operator** and synced from OpenBao.

*   **`VaultAuth`:** Defines *how* the operator authenticates to OpenBao. These resources are auto-generated by the Pulumi script when `vaultSecrets.createAuth` is set to `true` in `apps.yaml`.
*   **`VaultStaticSecret`:** Defines *what* secret to sync. These are also auto-generated based on the `vaultSecrets.secrets` list in `apps.yaml`.

### Vault Configuration

The `apps.yaml` definition abstracts the complexity of `VaultAuth` and `VaultStaticSecret` resources.

```yaml
# Example in apps.yaml
tailscale-operator:
  vaultSecrets:
    createAuth: true
    audiences:
      - vault
    secrets:
      - name: tailscale-auth
        mount: k8s
        path: "data/tailscale/auth"
        destination: "tailscale-auth"
```

This configuration tells the Pulumi generator to:
1.  Create a dedicated `ServiceAccount` and `VaultAuth` resource for this application.
2.  Create a `VaultStaticSecret` that authenticates using that `VaultAuth` to fetch the secret at `data/tailscale/auth`.

**Important:** The OpenBao (Vault) server must be configured with a matching Role that binds the generated Service Account name (e.g., `operator-auth-sa`) and namespace to the necessary policies.

