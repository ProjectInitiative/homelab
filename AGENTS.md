# Architecture & Agentic Workflow Guide

This document outlines the architectural patterns and conventions used in this repository for managing applications, clusters, and secrets. It serves as a primary reference for both human developers and AI agents when adding new services or modifying existing infrastructure.

## 1. Architecture Overview

This repository implements a **GitOps workflow** managed by Argo CD in a multi-cluster environment. However, unlike traditional GitOps setups that rely heavily on raw YAML or Kustomize overlays, this repository uses **Pulumi as a manifest generator** via an Argo CD Config Management Plugin (CMP).

### Key Components

*   **Nix Flake (`flake.nix`):**
    *   Ensures a reproducible development environment.
    *   Provides custom tools like `generate-manifests`, `diff-manifests`, and `import-crds`.
    *   Use `nix develop` or `direnv allow` to enter the environment.

*   **Pulumi (`pulumi/`):**
    *   Functions as a "Template Engine" for Kubernetes manifests.
    *   Reads configuration from `apps.yaml` (Catalog) and `clusters/*.yaml` (Deployments).
    *   **Crucially:** Pulumi is executed *on the fly* by Argo CD's Config Management Plugin (CMP). It generates the manifests dynamically before syncing.
    *   The `manifests/` directory (if present locally) is primarily for debugging and previewing changes, not the final source of truth for Argo CD in production.

*   **Argo CD:**
    *   Uses a custom plugin to run Pulumi against the repository state.
    *   Syncs the dynamically generated manifests to the target clusters (`homelab` and `capstan`).

*   **Secret Management (OpenBao & Vault Secrets Operator):**
    *   Secrets are stored in OpenBao (Vault).
    *   The **Vault Secrets Operator (VSO)** runs in the cluster and syncs secrets from Vault to Kubernetes `Secret` resources.
    *   The Pulumi generator simplifies VSO configuration via the `vaultSecrets` abstraction in `apps.yaml`.

---

## 2. Workflow for Adding New Services

To add a new service, you typically modify two files: the catalog (`apps.yaml`) and the cluster configuration (`clusters/<cluster>.yaml`).

### Step 1: Define the Application in `apps.yaml`

The `apps.yaml` file acts as a catalog of all available applications. Add a new entry under `catalog:`:

```yaml
catalog:
  my-new-service:
    # Source Configuration (Helm or Git)
    sources:
      - repoURL: https://charts.bitnami.com/bitnami
        chart: nginx
        targetRevision: 15.0.0
        helm:
          values: |
            service:
              type: ClusterIP

    # Sync Policy (Optional)
    syncPolicy:
      syncOptions:
        - CreateNamespace=true
        - ServerSideApply=true

    # Secret Management (Optional)
    vaultSecrets:
      createAuth: true # Auto-generates VaultAuth and ServiceAccount
      role: openbao-secrets-operator
      secrets:
        - name: my-service-creds
          path: "data/my-service/config" # Path in Vault
          destination: "secret-name-in-k8s"
```

**Key Fields:**
*   `sources`: Defines where the application comes from (Helm chart, Git repo, or local path).
*   `vaultSecrets`: If the app needs secrets, this section automates the creation of `VaultAuth` and `VaultStaticSecret` resources.
    *   `createAuth: true`: Automatically creates a dedicated `ServiceAccount` and `VaultAuth` for this app.
    *   `secrets`: List of secrets to sync.

### Step 2: Enable the Application in `clusters/<cluster>.yaml`

To deploy the application to a specific cluster (e.g., `clusters/mc.yaml`), add it to the `apps` list:

```yaml
apps:
  - name: my-new-service
    namespace: my-namespace
    # Optional: Override Helm values
    helm_values: |
      replicaCount: 3
    # Optional: Apply Kustomize patches
    patches:
      - patch: |
          - op: add
            path: /metadata/labels/new-label
            value: "true"
        target:
          kind: Deployment
          name: my-new-service-nginx
```

**Key Fields:**
*   `name`: Must match the key in `apps.yaml`.
*   `namespace`: The namespace to deploy into.
*   `helm_values`: Overrides the default Helm values defined in `apps.yaml`.
*   `patches`: JSON Patches (RFC 6902) to modify any resource generated by the app. This is powerful for last-mile customization without forking charts.

### Step 3: Generate and Verify (Preview)

After modifying the configuration, you should verify what Argo CD *will* see by generating a local preview.

1.  **Generate Manifests (Preview):**
    Run the generation script (provided by the Nix flake):
    ```bash
    nix run .#generate-manifests
    ```
    This updates your local `manifests/` directory.

2.  **Verify Changes:**
    Check the diff to ensure only the intended changes are present:
    ```bash
    nix run .#diff-manifests
    ```
    **Agent Tip:** This step simulates what the CI pipeline does. It allows you to see the diff between the current `main` branch state and your proposed changes.

3.  **Commit:**
    Commit the changes to `apps.yaml` and `clusters/*.yaml`. You can optionally commit `manifests/` if you want a record of the expected state, but remember that Argo CD regenerates them on the fly.

---

## 3. Agentic Tools Reference

This repository is designed to be agent-friendly. AI agents should follow these guidelines to safely and effectively modify the system.

### Interaction Rules

1.  **Edit Config, Not Manifests:**
    *   **Do:** Edit `apps.yaml` and `clusters/*.yaml`.
    *   **Don't:** Edit files in `manifests/` directly as the source of truth.
    *   **Don't:** Run `kubectl` commands to apply changes. All changes must go through the GitOps workflow.

2.  **Use Abstractions:**
    *   **Secrets:** Never hardcode secrets in YAML. Use the `vaultSecrets` block in `apps.yaml`. The system handles the complex wiring of `VaultAuth` and `VaultStaticSecret`.
    *   **Patches:** Use the `patches` list in `clusters/*.yaml` to modify specific fields in resources (e.g., adding annotations, changing resource limits) instead of trying to restructure the entire chart.

3.  **Verification Loop:**
    *   Agents should always perform a "Generate -> Diff -> Analyze" loop using the local tools.
    *   If `diff-manifests` returns a huge diff for unrelated apps, **STOP**. You may have broken the generation logic or a shared configuration.

### Tooling Availability

The `flake.nix` file ensures all necessary tools are available in the environment.
*   `generate-manifests`: Regenerates the local `manifests/` folder for preview.
*   `diff-manifests`: Compares the current local `manifests/` state with the `main` branch.
*   `python`: Available with all dependencies (Pulumi, PyYAML, etc.) for running custom scripts if needed.

### Debugging Generation Issues

If `generate-manifests` fails:
1.  Check `apps.yaml` syntax (YAML indentation is critical).
2.  Check `pulumi/__main__.py` logs (it prints validation warnings/errors).
3.  Ensure referenced Helm charts or Git repositories are accessible.

---

## 4. Key Abstractions

### `vaultSecrets`
Simplifies the consumption of secrets from Vault.
*   **Problem:** Setting up `VaultAuth`, `ServiceAccount`, and `VaultStaticSecret` manually is verbose and error-prone.
*   **Solution:** The `vaultSecrets` block in `apps.yaml` allows you to declare "I want secret X from Vault path Y mounted as Z". The Pulumi generator handles the rest.

### `critical: true`
*   **Usage:** Add `critical: true` to an app in `apps.yaml`.
*   **Effect:**
    *   Adds a `PodDisruptionBudget` to prevent voluntary evictions.
    *   May add specific annotations or labels to prevent accidental deletion (depending on cluster policy).

### `patches` (JSON Patch)
*   **Usage:** In `clusters/*.yaml` under an app entry.
*   **Format:** Standard JSON Patch list (`op`, `path`, `value`).
*   **Power:** Allows surgical modifications to *any* resource generated by the app, even if the upstream Helm chart doesn't support that specific configuration.
